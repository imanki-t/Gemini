// index.js
import {
 MessageFlags,
 ActionRowBuilder,
 ButtonBuilder,
 ButtonStyle,
 ChannelType,
 TextInputBuilder,
 TextInputStyle,
 ModalBuilder,
 PermissionsBitField,
 EmbedBuilder,
 AttachmentBuilder,
 ActivityType,
 ComponentType,
 REST,
 Routes,
 StringSelectMenuBuilder,
 StringSelectMenuOptionBuilder,
} from 'discord.js';
import {
 HarmBlockThreshold,
 HarmCategory
} from '@google/genai';
import fs from 'fs/promises';
import {
 createWriteStream
} from 'fs';
import path from 'path';
import {
 getTextExtractor
} from 'office-text-extractor';
import osu from 'node-os-utils';
import axios from 'axios';
import express from 'express';

import config from './config.js';
import {
 client,
 genAI,
 createPartFromUri,
 token,
 activeRequests,
 chatHistoryLock,
 state,
 TEMP_DIR,
 initialize,
 saveStateToFile,
 getHistory,
 updateChatHistory,
 getUserSettings,
 getServerSettings,
 getEffectiveSettings,
 initializeServerSettings,
 initializeUserSettings
} from './botManager.js';
import {
 delay,
 retryOperation,
 createErrorEmbed,
 createSuccessEmbed,
 createProcessingEmbed,
 createSettingsEmbed,
 processGif,
 processAudio,
 processVideo,
 cleanupTempFiles
} from './others.js';

const {
 mem,
 cpu
} = osu;

initialize().catch(console.error);

const safetySettings = [{
 category: HarmCategory.HARM_CATEGORY_HARASSMENT,
 threshold: HarmBlockThreshold.BLOCK_NONE,
}, {
 category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
 threshold: HarmBlockThreshold.BLOCK_NONE,
}, {
 category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
 threshold: HarmBlockThreshold.BLOCK_NONE,
}, {
 category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
 threshold: HarmBlockThreshold.BLOCK_NONE,
}, ];

const generationConfig = {
 temperature: 1.0,
 topP: 0.95,
 thinkingConfig: {
   thinkingBudget: -1
 }
};

const activities = config.activities.map(activity => ({
 name: activity.name,
 type: ActivityType[activity.type]
}));

import {
 commands
} from './commands.js';

let activityIndex = 0;
client.once('ready', async () => {
 console.log(`Logged in as ${client.user.tag}!`);

 const rest = new REST().setToken(token);
 try {
   console.log('Started refreshing application (/) commands.');

   await rest.put(
     Routes.applicationCommands(client.user.id), {
       body: commands
     },
   );

   console.log('Successfully reloaded application (/) commands.');
 } catch (error) {
   console.error(error);
 }

 client.user.setPresence({
   activities: [activities[activityIndex]],
   status: 'idle',
 });

 setInterval(() => {
   activityIndex = (activityIndex + 1) % activities.length;
   client.user.setPresence({
     activities: [activities[activityIndex]],
     status: 'idle',
   });
 }, 30000);
});

client.on('messageCreate', async (message) => {
 try {
   if (message.author.bot) return;
   if (message.content.startsWith('!')) return;

   const isDM = message.channel.type === ChannelType.DM;
   const userId = message.author.id;
   const guildId = message.guild?.id;

   if (guildId) {
     initializeServerSettings(guildId);
   }
   initializeUserSettings(userId);

   const effectiveSettings = getEffectiveSettings(userId, guildId);
   const serverSettings = getServerSettings(guildId);

   const isBlacklisted = guildId && serverSettings.blacklist.includes(userId);
   if (isBlacklisted) {
     return;
   }

   const mentioned = message.mentions.users.has(client.user.id);
   const isContinuous = effectiveSettings.continuousReply;
   const isAlwaysRespondChannel = state.alwaysRespondChannels[message.channelId];

   const shouldRespond =
     (isDM && !message.hasThreadId) ||
     (isAlwaysRespondChannel && !isDM) ||
     (isContinuous && !isDM) ||
     (mentioned && !isDM);

   if (shouldRespond) {
     if (activeRequests.has(userId)) {
       const embed = createErrorEmbed('Please wait until your previous action is complete.');
       await message.reply({
         embeds: [embed],
         ephemeral: true
       });
       return;
     }
     activeRequests.add(userId);
     await handleTextMessage(message, null);
   }
 } catch (error) {
   console.error('Error processing the message:', error);
   if (activeRequests.has(message.author.id)) {
     activeRequests.delete(message.author.id);
   }
 }
});

client.on('interactionCreate', async (interaction) => {
 try {
   const userId = interaction.user.id;
   const guildId = interaction.guild?.id;

   if (guildId) {
     initializeServerSettings(guildId);
   }
   initializeUserSettings(userId);

   const serverSettings = getServerSettings(guildId);
   const isBlacklisted = guildId && serverSettings.blacklist.includes(userId);

   if (isBlacklisted) {
     const embed = createErrorEmbed('You are blacklisted from using this bot in this server.');
     return interaction.reply({
       embeds: [embed],
       ephemeral: true
     });
   }

   if (interaction.isChatInputCommand()) {
     await handleCommandInteraction(interaction);
   } else if (interaction.isButton()) {
     await handleButtonInteraction(interaction);
   } else if (interaction.isStringSelectMenu()) {
     await handleSelectMenuInteraction(interaction);
   } else if (interaction.isModalSubmit()) {
     await handleModalSubmit(interaction);
   }
 } catch (error) {
   console.error('Error handling interaction:', error.message);
   if (interaction.deferred || interaction.replied) {
     await interaction.editReply({
       embeds: [createErrorEmbed(`An unexpected error occurred: ${error.message}`)],
       components: []
     }).catch(console.error);
   } else {
     await interaction.reply({
       embeds: [createErrorEmbed(`An unexpected error occurred: ${error.message}`)],
       ephemeral: true
     }).catch(console.error);
   }
 }
});

async function handleCommandInteraction(interaction) {
 if (!interaction.isChatInputCommand()) return;

 const commandHandlers = {
   settings: handleSettingsCommand,
   search: handleSearchCommand,
 };

 const handler = commandHandlers[interaction.commandName];
 if (handler) {
   if (activeRequests.has(interaction.user.id)) {
     const embed = createErrorEmbed('Please wait until your previous action is complete.');
     await interaction.reply({
       embeds: [embed],
       ephemeral: true
     });
     return;
   }
   activeRequests.add(interaction.user.id);
   await handler(interaction);
   if (interaction.commandName !== 'search') {
     activeRequests.delete(interaction.user.id);
   }
 } else {
   console.log(`Unknown command: ${interaction.commandName}`);
   activeRequests.delete(interaction.user.id);
 }
}

async function handleSearchCommand(interaction) {
 try {
   const prompt = interaction.options.getString('prompt');
   const attachment = interaction.options.getAttachment('attachment');

   if (!prompt && !attachment) {
     const embed = createErrorEmbed('You must provide either a prompt or an attachment for the /search command.');
     await interaction.reply({
       embeds: [embed],
       ephemeral: true
     });
     activeRequests.delete(interaction.user.id);
     return;
   }

   await interaction.deferReply();
   await handleTextMessage(interaction, {
     prompt,
     attachment
   });
 } catch (error) {
   console.error('Error in handleSearchCommand:', error);
   const embed = createErrorEmbed(`Failed to process search command: ${error.message}`);
   await interaction.editReply({
     embeds: [embed]
   });
   activeRequests.delete(interaction.user.id);
 }
}

async function handleSettingsCommand(interaction) {
 try {
   const userId = interaction.user.id;
   const guildId = interaction.guild?.id;
   const isDM = interaction.channel.type === ChannelType.DM;

   const embed = createSettingsEmbed(
     'Bot Settings',
     'Welcome to the settings panel. Please choose a category to configure.',
     interaction.user
   );

   const userButton = new ButtonBuilder()
     .setCustomId('settings_user_main')
     .setLabel('User Settings')
     .setStyle(ButtonStyle.Primary)
     .setEmoji('👤');

   const serverButton = new ButtonBuilder()
     .setCustomId('settings_server_main')
     .setLabel('Server Settings')
     .setStyle(ButtonStyle.Secondary)
     .setEmoji('🔧');

   if (isDM) {
     serverButton.setDisabled(true);
   } else if (guildId) {
     const member = await interaction.guild.members.fetch(userId);
     if (!member.permissions.has(PermissionsBitField.Flags.ManageGuild)) {
       serverButton.setDisabled(true);
     }
   }

   const row = new ActionRowBuilder().addComponents(userButton, serverButton);

   await interaction.reply({
     embeds: [embed],
     components: [row],
     ephemeral: true,
   });
 } catch (error) {
   console.error('Error showing settings:', error);
   await interaction.reply({
     embeds: [createErrorEmbed(`Failed to open settings: ${error.message}`)],
     ephemeral: true
   });
 }
}

async function handleButtonInteraction(interaction) {
 try {
   const [type, ...args] = interaction.customId.split('_');
   const action = args.join('_');

   if (type === 'settings') {
     await handleSettingsButton(interaction, action);
   } else if (type === 'delete') {
     await handleDeleteMessageInteraction(interaction, action);
   } else if (type === 'download') {
     await downloadMessage(interaction);
   } else if (type === 'stop') {
     // This is handled by a collector in handleModelResponse
     // But we send a reply here just in case.
     await interaction.reply({
       embeds: [createErrorEmbed('This button is handled automatically. If generation is not stopping, it may have already finished.')],
       ephemeral: true
     });
   }
 } catch (error) {
   console.error(`Error in handleButtonInteraction (${interaction.customId}):`, error);
   await interaction.followUp({
     embeds: [createErrorEmbed(`An error occurred: ${error.message}`)],
     ephemeral: true
   });
 }
}

async function handleSelectMenuInteraction(interaction) {
 try {
   const [type, target, action] = interaction.customId.split('_');
   const value = interaction.values[0];

   if (type !== 'settings') return;

   if (target === 'user' && action === 'model') {
     state.globalUserSettings[interaction.user.id].model = value;
   } else if (target === 'server' && action === 'model') {
     state.serverSettings[interaction.guild.id].model = value === 'default' ? null : value;
   }

   await saveStateToFile();
   await interaction.update({
     embeds: [createSuccessEmbed(`Setting updated successfully.`)],
     components: []
   });

   await delay(2000);

   if (target === 'user') {
     await showUserSettings(interaction, true);
   } else if (target === 'server') {
     await showServerSettings(interaction, true);
   }

 } catch (error) {
   console.error('Error handling select menu:', error);
   await interaction.followUp({
     embeds: [createErrorEmbed(`Failed to update setting: ${error.message}`)],
     ephemeral: true
   });
 }
}

async function handleModalSubmit(interaction) {
 try {
   const [type, target, action] = interaction.customId.split('_');
   if (type !== 'settings') return;

   let setting, value, successMessage, updateFn;

   if (target === 'user') {
     if (action === 'personality') {
       setting = 'customPersonality';
       value = interaction.fields.getTextInputValue('settings_input');
       state.globalUserSettings[interaction.user.id][setting] = value;
       successMessage = 'User personality updated.';
       updateFn = () => showUserSettings(interaction, true);
     } else if (action === 'color') {
       setting = 'responseColor';
       value = interaction.fields.getTextInputValue('settings_input');
       if (!/^#[0-9A-F]{6}$/i.test(value)) {
         throw new Error('Invalid hex color. Must be in `#RRGGBB` format.');
       }
       state.globalUserSettings[interaction.user.id][setting] = value;
       successMessage = 'User response color updated.';
       updateFn = () => showUserSettings(interaction, true);
     }
   } else if (target === 'server') {
     const guildId = interaction.guild.id;
     if (action === 'personality') {
       setting = 'customPersonality';
       value = interaction.fields.getTextInputValue('settings_input');
       state.serverSettings[guildId][setting] = value === '' ? null : value;
       successMessage = 'Server personality updated.';
       updateFn = () => showServerSettings(interaction, true);
     } else if (action === 'color') {
       setting = 'responseColor';
       value = interaction.fields.getTextInputValue('settings_input');
       if (value === '') {
         value = null;
       } else if (!/^#[0-9A-F]{6}$/i.test(value)) {
         throw new Error('Invalid hex color. Must be in `#RRGGBB` format.');
       }
       state.serverSettings[guildId][setting] = value;
       successMessage = 'Server response color updated.';
       updateFn = () => showServerSettings(interaction, true);
     } else if (action === 'blacklistadd') {
       const userId = interaction.fields.getTextInputValue('settings_input');
       const member = await interaction.guild.members.fetch(userId).catch(() => null);
       if (!member) throw new Error('User not found in this server.');
       if (!state.serverSettings[guildId].blacklist.includes(userId)) {
         state.serverSettings[guildId].blacklist.push(userId);
       }
       successMessage = `User \`${member.user.tag}\` added to blacklist.`;
       updateFn = () => showServerSettings(interaction, true);
     } else if (action === 'blacklistremove') {
       const userId = interaction.fields.getTextInputValue('settings_input');
       const member = await interaction.guild.members.fetch(userId).catch(() => null);
       state.serverSettings[guildId].blacklist = state.serverSettings[guildId].blacklist.filter(id => id !== userId);
       successMessage = `User ${member ? `\`${member.user.tag}\`` : `ID \`${userId}\``} removed from blacklist.`;
       updateFn = () => showServerSettings(interaction, true);
     }
   }

   if (successMessage) {
     await saveStateToFile();
     await interaction.reply({
       embeds: [createSuccessEmbed(successMessage)],
       ephemeral: true
     });
     await updateFn();
   } else {
     throw new Error('Unknown modal action.');
   }

 } catch (error) {
   console.error('Error handling modal submit:', error);
   await interaction.followUp({
     embeds: [createErrorEmbed(`Failed to save settings: ${error.message}`)],
     ephemeral: true
   });
 }
}

async function handleSettingsButton(interaction, action) {
 const isUpdate = interaction.isButton();
 const update = async (options) => {
   if (isUpdate) {
     await interaction.update(options);
   } else {
     await interaction.reply(options);
   }
 };

 try {
   if (action === 'user_main') {
     await showUserSettings(interaction, isUpdate);
   } else if (action === 'server_main') {
     await showServerSettings(interaction, isUpdate);
   } else if (action === 'main') {
     await handleSettingsCommand(interaction);
   } else if (action.startsWith('user_')) {
     await handleUserSettingAction(interaction, action.replace('user_', ''));
   } else if (action.startsWith('server_')) {
     await handleServerSettingAction(interaction, action.replace('server_', ''));
   }
 } catch (error) {
   console.error(`Error in handleSettingsButton (${action}):`, error);
   await update({
     embeds: [createErrorEmbed(`Failed to process setting: ${error.message}`)],
     components: [],
     ephemeral: true
   });
 }
}

async function showUserSettings(interaction, isUpdate = false) {
 const userId = interaction.user.id;
 const settings = getUserSettings(userId);
 const update = isUpdate ? interaction.update.bind(interaction) : interaction.reply.bind(interaction);

 const embed = createSettingsEmbed(
   '👤 User Settings',
   'Manage your personal bot settings. These settings apply in all servers and DMs unless overridden by a server admin.',
   interaction.user
 );

 embed.addFields({
   name: 'Current Settings',
   value: `
- **Model**: \`${settings.model}\`
- **Continuous Reply**: \`${settings.continuousReply ? 'On' : 'Off'}\`
- **Response Format**: \`${settings.responseFormat}\`
- **Response Color**: \`${settings.responseColor}\`
- **Show Action Buttons**: \`${settings.showActionButtons ? 'On' : 'Off'}\`
- **Custom Personality**: \`${settings.customPersonality ? 'Set' : 'Not Set'}\`
     `,
 });

 const components = [];
 const row1 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_user_model').setLabel('Model').setStyle(ButtonStyle.Secondary).setEmoji('🤖'),
   new ButtonBuilder().setCustomId('settings_user_continuous').setLabel('Continuous Reply').setStyle(ButtonStyle.Secondary).setEmoji('🔄'),
   new ButtonBuilder().setCustomId('settings_user_format').setLabel('Response Format').setStyle(ButtonStyle.Secondary).setEmoji('📄')
 );
 const row2 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_user_color').setLabel('Response Color').setStyle(ButtonStyle.Secondary).setEmoji('🎨'),
   new ButtonBuilder().setCustomId('settings_user_actions').setLabel('Action Buttons').setStyle(ButtonStyle.Secondary).setEmoji('🔘'),
   new ButtonBuilder().setCustomId('settings_user_personality').setLabel('Personality').setStyle(ButtonStyle.Secondary).setEmoji('🎭')
 );
 const row3 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_user_clearhistory').setLabel('Clear History').setStyle(ButtonStyle.Danger).setEmoji('🧹'),
   new ButtonBuilder().setCustomId('settings_user_downloadhistory').setLabel('Download History').setStyle(ButtonStyle.Primary).setEmoji('💾')
 );
 const row4 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_main').setLabel('Back').setStyle(ButtonStyle.Success).setEmoji('⬅️')
 );

 if (settings.responseFormat !== 'Embedded') {
   row2.components[0].setDisabled(true);
 }

 components.push(row1, row2, row3, row4);

 await update({
   embeds: [embed],
   components: components,
   ephemeral: true
 });
}

async function showServerSettings(interaction, isUpdate = false) {
 const guildId = interaction.guild.id;
 if (!guildId) {
   return interaction.update({
     embeds: [createErrorEmbed('Server settings are only available in a server.')],
     components: [],
     ephemeral: true
   });
 }

 const member = await interaction.guild.members.fetch(interaction.user.id);
 if (!member.permissions.has(PermissionsBitField.Flags.ManageGuild)) {
   return interaction.update({
     embeds: [createErrorEmbed('You must have "Manage Server" permissions to access this menu.')],
     components: [],
     ephemeral: true
   });
 }

 const settings = getServerSettings(guildId);
 const update = isUpdate ? interaction.update.bind(interaction) : interaction.reply.bind(interaction);

 const embed = createSettingsEmbed(
   '🔧 Server Settings',
   'Manage settings for this server. Settings here can override individual user preferences.',
   interaction.user
 );

 embed.addFields({
   name: 'Current Settings',
   value: `
- **Override User Settings**: \`${settings.overrideUserSettings ? 'On' : 'Off'}\`
- **Model**: \`${settings.model || 'User Default'}\`
- **Continuous Reply**: \`${settings.continuousReply ? 'On' : 'Off'}\` (Requires Override)
- **Response Format**: \`${settings.responseFormat || 'User Default'}\` (Requires Override)
- **Response Color**: \`${settings.responseColor || 'User Default'}\` (Requires Override)
- **Show Action Buttons**: \`${settings.showActionButtons ? 'On' : 'Off'}\` (Requires Override)
- **Custom Personality**: \`${settings.customPersonality ? 'Set' : 'User Default'}\` (Requires Override)
- **Blacklisted Users**: \`${settings.blacklist.length}\`
- **Always Respond Channels**: \`${Object.keys(state.alwaysRespondChannels).filter(id => interaction.guild.channels.cache.has(id)).length}\`
- **Server-Wide History**: \`${settings.serverChatHistory ? 'On' : 'Off'}\`
     `,
 });

 const components = [];
 const row1 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_server_override').setLabel('Toggle Override').setStyle(settings.overrideUserSettings ? ButtonStyle.Danger : ButtonStyle.Success).setEmoji('⚠️'),
   new ButtonBuilder().setCustomId('settings_server_model').setLabel('Model').setStyle(ButtonStyle.Secondary).setEmoji('🤖'),
   new ButtonBuilder().setCustomId('settings_server_personality').setLabel('Personality').setStyle(ButtonStyle.Secondary).setEmoji('🎭')
 );
 const row2 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_server_continuous').setLabel('Continuous Reply').setStyle(ButtonStyle.Secondary).setEmoji('🔄'),
   new ButtonBuilder().setCustomId('settings_server_format').setLabel('Response Format').setStyle(ButtonStyle.Secondary).setEmoji('📄'),
   new ButtonBuilder().setCustomId('settings_server_color').setLabel('Response Color').setStyle(ButtonStyle.Secondary).setEmoji('🎨')
 );
 const row3 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_server_actions').setLabel('Action Buttons').setStyle(ButtonStyle.Secondary).setEmoji('🔘'),
   new ButtonBuilder().setCustomId('settings_server_blacklist').setLabel('Blacklist Menu').setStyle(ButtonStyle.Danger).setEmoji('🚫'),
   new ButtonBuilder().setCustomId('settings_server_status').setLabel('Bot Status').setStyle(ButtonStyle.Primary).setEmoji('📊')
 );
 const row4 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_server_alwaysrespond').setLabel('Always Respond').setStyle(ButtonStyle.Secondary).setEmoji('📣'),
   new ButtonBuilder().setCustomId('settings_server_serverhistory').setLabel('Server History').setStyle(ButtonStyle.Secondary).setEmoji('📚')
 );
 const row5 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('settings_main').setLabel('Back').setStyle(ButtonStyle.Success).setEmoji('⬅️')
 );

 if (!settings.overrideUserSettings) {
   row1.components[1].setDisabled(true);
   row1.components[2].setDisabled(true);
   row2.components[0].setDisabled(true);
   row2.components[1].setDisabled(true);
   row2.components[2].setDisabled(true);
   row3.components[0].setDisabled(true);
 }

 if (settings.responseFormat !== 'Embedded') {
   row2.components[2].setDisabled(true);
 }

 components.push(row1, row2, row3, row4, row5);

 await update({
   embeds: [embed],
   components: components,
   ephemeral: true
 });
}

async function handleUserSettingAction(interaction, action) {
 const userId = interaction.user.id;
 const settings = getUserSettings(userId);
 let ephemeralReply = true;
 let replyOptions = {};

 switch (action) {
   case 'model':
     const modelOptions = Object.keys(config.models).map(key =>
       new StringSelectMenuOptionBuilder()
       .setLabel(key)
       .setValue(config.models[key])
       .setDefault(settings.model === config.models[key])
     );
     const selectMenu = new StringSelectMenuBuilder()
       .setCustomId('settings_user_model')
       .setPlaceholder('Select a model')
       .addOptions(modelOptions);
     replyOptions = {
       embeds: [createSettingsEmbed('Select Model', 'Choose your preferred Gemini model.', interaction.user)],
       components: [new ActionRowBuilder().addComponents(selectMenu)],
       ephemeral: true
     };
     await interaction.update(replyOptions);
     return;

   case 'continuous':
     settings.continuousReply = !settings.continuousReply;
     replyOptions = {
       embeds: [createSuccessEmbed(`Continuous Reply set to: \`${settings.continuousReply ? 'On' : 'Off'}\``)],
       ephemeral: true
     };
     break;

   case 'format':
     settings.responseFormat = settings.responseFormat === 'Embedded' ? 'Normal' : 'Embedded';
     replyOptions = {
       embeds: [createSuccessEmbed(`Response Format set to: \`${settings.responseFormat}\``)],
       ephemeral: true
     };
     break;

   case 'color':
     if (settings.responseFormat !== 'Embedded') {
       replyOptions = {
         embeds: [createErrorEmbed('You can only set a response color when your format is "Embedded".')],
         ephemeral: true
       };
     } else {
       const modal = new ModalBuilder()
         .setCustomId('settings_user_color')
         .setTitle('Set Response Color')
         .addComponents(new ActionRowBuilder().addComponents(
           new TextInputBuilder()
           .setCustomId('settings_input')
           .setLabel('Hex Color Code')
           .setStyle(TextInputStyle.Short)
           .setPlaceholder('#505050')
           .setValue(settings.responseColor)
           .setRequired(true)
         ));
       await interaction.showModal(modal);
       return;
     }
     break;

   case 'actions':
     settings.showActionButtons = !settings.showActionButtons;
     replyOptions = {
       embeds: [createSuccessEmbed(`Show Action Buttons set to: \`${settings.showActionButtons ? 'On' : 'Off'}\``)],
       ephemeral: true
     };
     break;

   case 'personality':
     const modal = new ModalBuilder()
       .setCustomId('settings_user_personality')
       .setTitle('Set Custom Personality')
       .addComponents(new ActionRowBuilder().addComponents(
         new TextInputBuilder()
         .setCustomId('settings_input')
         .setLabel('Personality Instructions')
         .setStyle(TextInputStyle.Paragraph)
         .setPlaceholder('e.g., You are a helpful assistant...')
         .setValue(settings.customPersonality || '')
         .setRequired(false)
       ));
     await interaction.showModal(modal);
     return;

   case 'clearhistory':
     state.chatHistories[userId] = {};
     replyOptions = {
       embeds: [createSuccessEmbed('Your personal chat history has been cleared.')],
       ephemeral: true
     };
     break;

   case 'downloadhistory':
     ephemeralReply = false;
     await interaction.deferReply({
       ephemeral: true
     });
     await downloadConversation(interaction);
     return;

   default:
     replyOptions = {
       embeds: [createErrorEmbed('Unknown user setting action.')],
       ephemeral: true
     };
 }

 await saveStateToFile();
 if (ephemeralReply) {
   await interaction.reply(replyOptions);
   await showUserSettings(interaction, true);
 }
}

async function handleServerSettingAction(interaction, action) {
 const guildId = interaction.guild.id;
 const settings = getServerSettings(guildId);
 let replyOptions = {};

 switch (action) {
   case 'override':
     settings.overrideUserSettings = !settings.overrideUserSettings;
     replyOptions = {
       embeds: [createSuccessEmbed(`Override User Settings set to: \`${settings.overrideUserSettings ? 'On' : 'Off'}\``)],
       ephemeral: true
     };
     break;

   case 'model':
     const modelOptions = [
       new StringSelectMenuOptionBuilder()
       .setLabel('Use User Default')
       .setValue('default')
       .setDefault(settings.model === null),
       ...Object.keys(config.models).map(key =>
         new StringSelectMenuOptionBuilder()
         .setLabel(key)
         .setValue(config.models[key])
         .setDefault(settings.model === config.models[key])
       )
     ];
     const selectMenu = new StringSelectMenuBuilder()
       .setCustomId('settings_server_model')
       .setPlaceholder('Select a model (requires override)')
       .addOptions(modelOptions);
     replyOptions = {
       embeds: [createSettingsEmbed('Select Server Model', 'Choose the Gemini model for this server.', interaction.user)],
       components: [new ActionRowBuilder().addComponents(selectMenu)],
       ephemeral: true
     };
     await interaction.update(replyOptions);
     return;

   case 'personality':
     const personalityModal = new ModalBuilder()
       .setCustomId('settings_server_personality')
       .setTitle('Set Server Personality')
       .addComponents(new ActionRowBuilder().addComponents(
         new TextInputBuilder()
         .setCustomId('settings_input')
         .setLabel('Personality (Leave empty for user default)')
         .setStyle(TextInputStyle.Paragraph)
         .setPlaceholder('e.g., You are a helpful assistant...')
         .setValue(settings.customPersonality || '')
         .setRequired(false)
       ));
     await interaction.showModal(personalityModal);
     return;

   case 'continuous':
     settings.continuousReply = !settings.continuousReply;
     replyOptions = {
       embeds: [createSuccessEmbed(`Server Continuous Reply set to: \`${settings.continuousReply ? 'On' : 'Off'}\` (Requires Override)`)],
       ephemeral: true
     };
     break;

   case 'format':
     let newFormat = 'User Default';
     if (settings.responseFormat === 'User Default') newFormat = 'Embedded';
     else if (settings.responseFormat === 'Embedded') newFormat = 'Normal';
     settings.responseFormat = newFormat === 'User Default' ? null : newFormat;

     replyOptions = {
       embeds: [createSuccessEmbed(`Server Response Format set to: \`${newFormat}\` (Requires Override)`)],
       ephemeral: true
     };
     break;

   case 'color':
     if (settings.responseFormat !== 'Embedded') {
       replyOptions = {
         embeds: [createErrorEmbed('You can only set a response color when the server format is "Embedded".')],
         ephemeral: true
       };
     } else {
       const colorModal = new ModalBuilder()
         .setCustomId('settings_server_color')
         .setTitle('Set Server Response Color')
         .addComponents(new ActionRowBuilder().addComponents(
           new TextInputBuilder()
           .setCustomId('settings_input')
           .setLabel('Hex Color (Leave empty for user default)')
           .setStyle(TextInputStyle.Short)
           .setPlaceholder('#505050')
           .setValue(settings.responseColor || '')
           .setRequired(false)
         ));
       await interaction.showModal(colorModal);
       return;
     }
     break;

   case 'actions':
     settings.showActionButtons = !settings.showActionButtons;
     replyOptions = {
       embeds: [createSuccessEmbed(`Server Show Action Buttons set to: \`${settings.showActionButtons ? 'On' : 'Off'}\` (Requires Override)`)],
       ephemeral: true
     };
     break;

   case 'blacklist':
     const blacklistEmbed = createSettingsEmbed(
       '🚫 Blacklist Management',
       'Add or remove users from the blacklist. Blacklisted users cannot interact with the bot in this server.',
       interaction.user
     );
     const blacklistRow = new ActionRowBuilder().addComponents(
       new ButtonBuilder().setCustomId('settings_server_blacklistadd').setLabel('Add User').setStyle(ButtonStyle.Danger).setEmoji('➕'),
       new ButtonBuilder().setCustomId('settings_server_blacklistremove').setLabel('Remove User').setStyle(ButtonStyle.Success).setEmoji('➖'),
       new ButtonBuilder().setCustomId('settings_server_main').setLabel('Back to Server Settings').setStyle(ButtonStyle.Secondary).setEmoji('⬅️')
     );
     await interaction.update({
       embeds: [blacklistEmbed],
       components: [blacklistRow],
       ephemeral: true
     });
     return;

   case 'blacklistadd':
     const addModal = new ModalBuilder()
       .setCustomId('settings_server_blacklistadd')
       .setTitle('Add to Blacklist')
       .addComponents(new ActionRowBuilder().addComponents(
         new TextInputBuilder()
         .setCustomId('settings_input')
         .setLabel('User ID')
         .setStyle(TextInputStyle.Short)
         .setPlaceholder('Enter User ID to blacklist')
         .setRequired(true)
       ));
     await interaction.showModal(addModal);
     return;

   case 'blacklistremove':
     const removeModal = new ModalBuilder()
       .setCustomId('settings_server_blacklistremove')
       .setTitle('Remove from Blacklist')
       .addComponents(new ActionRowBuilder().addComponents(
         new TextInputBuilder()
         .setCustomId('settings_input')
         .setLabel('User ID')
         .setStyle(TextInputStyle.Short)
         .setPlaceholder('Enter User ID to whitelist')
         .setRequired(true)
       ));
     await interaction.showModal(removeModal);
     return;

   case 'status':
     await handleStatusCommand(interaction);
     return;

   case 'alwaysrespond':
     await handleRespondToAllCommand(interaction);
     return;

   case 'serverhistory':
     settings.serverChatHistory = !settings.serverChatHistory;
     if (settings.serverChatHistory) {
       replyOptions = {
         embeds: [createSuccessEmbed('Server-Wide History is now **On**. All users in this server will share one conversation history.')],
         ephemeral: true
       };
     } else {
       delete state.chatHistories[guildId];
       replyOptions = {
         embeds: [createSuccessEmbed('Server-Wide History is now **Off**. History has been cleared.')],
         ephemeral: true
       };
     }
     break;

   default:
     replyOptions = {
       embeds: [createErrorEmbed('Unknown server setting action.')],
       ephemeral: true
     };
 }

 await saveStateToFile();
 await interaction.reply(replyOptions);
 await showServerSettings(interaction, true);
}

async function handleRespondToAllCommand(interaction) {
 try {
   const channelId = interaction.channelId;
   if (state.alwaysRespondChannels[channelId]) {
     delete state.alwaysRespondChannels[channelId];
     await interaction.reply({
       embeds: [createSuccessEmbed(`Bot will no longer respond to all messages in this channel.`)],
       ephemeral: true
     });
   } else {
     state.alwaysRespondChannels[channelId] = true;
     await interaction.reply({
       embeds: [createSuccessEmbed(`Bot will now respond to all messages in this channel.`)],
       ephemeral: true
     });
   }
   await saveStateToFile();
   await showServerSettings(interaction, true);
 } catch (error) {
   console.error('Error in handleRespondToAllCommand:', error);
   await interaction.followUp({
     embeds: [createErrorEmbed(`Failed to toggle setting: ${error.message}`)],
     ephemeral: true
   });
 }
}

async function handleStatusCommand(interaction) {
 try {
   await interaction.reply({
     embeds: [createProcessingEmbed('Fetching Status', 'Getting system information...')],
     ephemeral: true
   });

   const [{
     totalMemMb,
     usedMemMb,
     freeMemMb,
     freeMemPercentage
   }, cpuPercentage] = await Promise.all([
     mem.info(),
     cpu.usage()
   ]);

   const now = new Date();
   const nextReset = new Date();
   nextReset.setHours(0, 0, 0, 0);
   if (nextReset <= now) {
     nextReset.setDate(now.getDate() + 1);
   }
   const timeLeftMillis = nextReset - now;
   const hours = Math.floor(timeLeftMillis / 3600000);
   const minutes = Math.floor((timeLeftMillis % 3600000) / 60000);
   const seconds = Math.floor((timeLeftMillis % 60000) / 1000);
   const timeLeft = `${hours}h ${minutes}m ${seconds}s`;

   const embed = new EmbedBuilder()
     .setColor(config.hexColour)
     .setTitle('System Information')
     .addFields({
       name: 'Memory (RAM)',
       value: `Total: \`${totalMemMb}\` MB\nUsed: \`${usedMemMb}\` MB\nFree: \`${freeMemMb}\` MB (\`${freeMemPercentage}\`%)`,
       inline: true
     }, {
       name: 'CPU',
       value: `Usage: \`${cpuPercentage}\`%`,
       inline: true
     }, {
       name: 'Time Until Next Reset',
       value: timeLeft,
       inline: true
     })
     .setTimestamp();

   await interaction.editReply({
     embeds: [embed],
     ephemeral: true
   });

 } catch (error) {
   console.error('Error in handleStatusCommand:', error);
   await interaction.editReply({
     embeds: [createErrorEmbed(`Failed to fetch status: ${error.message}`)],
     ephemeral: true
   });
 }
}

async function handleDeleteMessageInteraction(interaction, msgId) {
 try {
   const userId = interaction.user.id;
   const channel = interaction.channel;
   const message = channel ? (await channel.messages.fetch(msgId).catch(() => null)) : null;

   let historyId = null;
   if (state.chatHistories[userId] && state.chatHistories[userId][msgId]) {
     historyId = userId;
   } else if (interaction.guild && state.chatHistories[interaction.guild.id] && state.chatHistories[interaction.guild.id][msgId]) {
     historyId = interaction.guild.id;
   }

   if (historyId) {
     delete state.chatHistories[historyId][msgId];
     await saveStateToFile();
     await interaction.message.delete().catch(console.error);
     if (message) {
       await message.delete().catch(console.error);
     }
     await interaction.reply({
       embeds: [createSuccessEmbed('Message and its history entry deleted.')],
       ephemeral: true
     });
   } else {
     await interaction.reply({
       embeds: [createErrorEmbed('Could not find history for this message, or it was not generated by you.')],
       ephemeral: true
     });
   }
 } catch (error) {
   console.error('Error deleting message:', error);
   await interaction.followUp({
     embeds: [createErrorEmbed('An error occurred while trying to delete the message.')],
     ephemeral: true
   });
 }
}

async function handleTextMessage(interactionOrMessage, searchData = null) {
 const isInteraction = !interactionOrMessage.author;
 const user = isInteraction ? interactionOrMessage.user : interactionOrMessage.author;
 const channel = interactionOrMessage.channel;
 const guildId = interactionOrMessage.guild?.id;
 const userId = user.id;

 let messageContent = '';
 let attachments = [];
 let replyFunction = async (options) => {
   return isInteraction ? interactionOrMessage.editReply(options) : interactionOrMessage.reply(options);
 };
 let originalMessage = isInteraction ? null : interactionOrMessage;

 if (searchData) {
   messageContent = searchData.prompt || '';
   if (searchData.attachment) {
     attachments = [searchData.attachment];
   }
 } else {
   messageContent = interactionOrMessage.content.replace(new RegExp(`<@!?${client.user.id}>`), '').trim();
   attachments = Array.from(interactionOrMessage.attachments.values());
 }

 if (messageContent === '' && attachments.length === 0) {
   await replyFunction({
     embeds: [createErrorEmbed("It looks like you didn't say anything or provide an attachment. What would you like to talk about?")],
     ephemeral: true
   });
   activeRequests.delete(userId);
   return;
 }

 let typingInterval;
 if (!isInteraction) {
   channel.sendTyping();
   typingInterval = setInterval(() => {
     channel.sendTyping();
   }, 4000);
   setTimeout(() => {
     clearInterval(typingInterval);
   }, 120000);
 }

 let botMessage;
 let parts = [];
 let tempFiles = [];

 try {
   const processingEmbed = createProcessingEmbed(
     'Processing Request',
     'Let me think...\n\n- [🔁] Text Attachment Check\n- [🔁] Media Attachment Check'
   );
   botMessage = await replyFunction({
     embeds: [processingEmbed],
     components: [],
     fetchReply: true
   });

   const effectiveSettings = getEffectiveSettings(userId, guildId);
   if (effectiveSettings.isOverride && isInteraction) {
     await user.send({
       embeds: [createSettingsEmbed(
         'Server Settings Override',
         `Heads up! The settings in **${interactionOrMessage.guild.name}** are currently overriding your personal settings.`,
         user
       )]
     }).catch(console.error);
   }

   let fileContentText = '';
   for (const attachment of attachments) {
     const fileType = path.extname(attachment.name) || '';
     const supportedTextFiles = ['.html', '.js', '.css', '.json', '.xml', '.csv', '.py', '.java', '.sql', '.log', '.md', '.txt', '.docx', '.pptx'];
     if (supportedTextFiles.includes(fileType.toLowerCase())) {
       fileContentText += await extractFileText(attachment);
     }
   }
   if (fileContentText) {
     messageContent += `\n\n--- Attached File Content ---\n${fileContentText}`;
   }
   parts.push({
     text: messageContent
   });

   processingEmbed.setDescription('Let me think...\n\n- [☑️] Text Attachment Check\n- [🔁] Media Attachment Check');
   await botMessage.edit({
     embeds: [processingEmbed]
   });

   const mediaAttachments = attachments.filter(att => {
     const contentType = (att.contentType || "").toLowerCase();
     const supportedTextFiles = ['.html', '.js', '.css', '.json', '.xml', '.csv', '.py', '.java', '.sql', '.log', '.md', '.txt', '.docx', '.pptx'];
     return !supportedTextFiles.includes(path.extname(att.name).toLowerCase());
   });

   for (const attachment of mediaAttachments) {
     const [processedParts, filesToClean] = await processMediaAttachment(attachment);
     parts.push(...processedParts);
     tempFiles.push(...filesToClean);
   }

   processingEmbed.setDescription('Let me think...\n\n- [☑️] Text Attachment Check\n- [☑️] Media Attachment Check\n\nAll checks done. Waiting for the response...');
   await botMessage.edit({
     embeds: [processingEmbed]
   });

 } catch (error) {
   console.error('Error processing attachments:', error);
   clearInterval(typingInterval);
   await botMessage.edit({
     embeds: [createErrorEmbed(`Error processing files: ${error.message}`)]
   });
   activeRequests.delete(userId);
   await cleanupTempFiles(tempFiles);
   return;
 }

 const effectiveSettings = getEffectiveSettings(userId, guildId);
 const serverSettings = getServerSettings(guildId);

 let instructions = effectiveSettings.customPersonality || config.defaultPersonality;
 let historyId = userId;

 if (guildId) {
   if (serverSettings.serverChatHistory) {
     historyId = guildId;
     if (serverSettings.customPersonality) {
       instructions = serverSettings.customPersonality;
     }
   } else if (state.channelWideChatHistory[channel.id]) {
     historyId = channel.id;
     if (state.customInstructions[channel.id]) {
       instructions = state.customInstructions[channel.id];
     }
   }

   const userInfo = {
     username: user.username,
     displayName: user.displayName,
     guildName: interactionOrMessage.guild.name,
   };
   const infoStr = `\n\nYou are currently engaging with users in the ${userInfo.guildName} Discord server.\n\n## Current User Information\nUsername: \`${userInfo.username}\`\nDisplay Name: \`${userInfo.displayName}\``;
   instructions += infoStr;
 }

 const model = genAI.getGenerativeModel({
   model: effectiveSettings.model,
   systemInstruction: {
     role: "system",
     parts: [{
       text: instructions
     }]
   },
   generationConfig: generationConfig,
   safetySettings: safetySettings,
   tools: [{
     googleSearch: {}
   }, {
     codeExecution: {}
   }]
 });

 const chat = model.startChat({
   history: getHistory(historyId)
 });

 await handleModelResponse(
   botMessage,
   chat,
   parts,
   interactionOrMessage,
   typingInterval,
   historyId,
   effectiveSettings,
   originalMessage
 );

 await cleanupTempFiles(tempFiles);
}

async function extractFileText(attachment) {
 try {
   const fileType = path.extname(attachment.name).toLowerCase();
   let fileContent;
   if (fileType === '.docx' || fileType === '.pptx') {
     const extractor = getTextExtractor();
     fileContent = await extractor.extractText({
       input: attachment.url,
       type: 'url'
     });
   } else {
     const response = await axios.get(attachment.url);
     fileContent = response.data;
     if (typeof fileContent !== 'string') {
       fileContent = JSON.stringify(fileContent, null, 2);
     }
   }
   return `\n\n[\`${attachment.name}\` File Content]:\n\`\`\`\n${fileContent.substring(0, 2000)}\n\`\`\``;
 } catch (error) {
   console.error(`Error reading file ${attachment.name}: ${error.message}`);
   return `\n\n[Error reading file \`${attachment.name}\`]\n`;
 }
}

async function downloadFile(url, filePath) {
 const writer = createWriteStream(filePath);
 const response = await axios({
   url,
   method: 'GET',
   responseType: 'stream',
 });
 response.data.pipe(writer);
 return new Promise((resolve, reject) => {
   writer.on('finish', resolve);
   writer.on('error', reject);
 });
}

function sanitizeFileName(fileName) {
 return fileName
   .toLowerCase()
   .replace(/[^a-z0-9-._]/g, '-')
   .replace(/^-+|-+$/g, '');
}

async function processMediaAttachment(attachment) {
 const sanitizedFileName = sanitizeFileName(attachment.name);
 const uniqueTempFilename = `${Date.now()}-${attachment.id}-${sanitizedFileName}`;
 const filePath = path.join(TEMP_DIR, uniqueTempFilename);
 let filesToClean = [filePath];
 let parts = [];

 try {
   await downloadFile(attachment.url, filePath);
   const contentType = (attachment.contentType || "").toLowerCase();

   if (contentType.startsWith('image/gif')) {
     const framePaths = await processGif(filePath);
     filesToClean.push(path.dirname(framePaths[0]));
     for (const framePath of framePaths) {
       const uploadResult = await genAI.files.upload({
         file: framePath,
         config: {
           mimeType: 'image/png'
         }
       });
       parts.push(createPartFromUri(uploadResult.uri, uploadResult.mimeType));
     }
   } else if (contentType.startsWith('image/')) {
     const uploadResult = await genAI.files.upload({
       file: filePath,
       config: {
         mimeType: contentType
       }
     });
     parts.push(createPartFromUri(uploadResult.uri, uploadResult.mimeType));
   } else if (contentType.startsWith('audio/')) {
     const processedAudioPath = await processAudio(filePath);
     filesToClean.push(processedAudioPath);
     const uploadResult = await genAI.files.upload({
       file: processedAudioPath,
       config: {
         mimeType: 'audio/mp3'
       }
     });
     parts.push(createPartFromUri(uploadResult.uri, uploadResult.mimeType));
   } else if (contentType.startsWith('video/')) {
     const processedVideoPath = await processVideo(filePath);
     filesToClean.push(processedVideoPath);
     const uploadResult = await genAI.files.upload({
       file: processedVideoPath,
       config: {
         mimeType: 'audio/mp3'
       }
     });
     parts.push(createPartFromUri(uploadResult.uri, uploadResult.mimeType));
   } else if (contentType === 'application/pdf') {
     const uploadResult = await genAI.files.upload({
       file: filePath,
       config: {
         mimeType: contentType
       }
     });
     parts.push(createPartFromUri(uploadResult.uri, uploadResult.mimeType));
   } else {
     console.log(`Skipping unsupported file type: ${contentType} (${attachment.name})`);
   }

   return [parts, filesToClean];
 } catch (error) {
   console.error(`Error processing attachment ${sanitizedFileName}:`, error);
   await cleanupTempFiles(filesToClean);
   throw error;
 }
}

async function handleModelResponse(botMessage, chat, parts, interactionOrMessage, typingInterval, historyId, effectiveSettings, originalMessage) {
 const userId = isInteraction(interactionOrMessage) ? interactionOrMessage.user.id : interactionOrMessage.author.id;
 const {
   responseFormat,
   responseColor,
   showActionButtons,
   continuousReply
 } = effectiveSettings;
 const maxCharacterLimit = responseFormat === 'Embedded' ? 3900 : 1900;
 let attempts = 3;

 let updateTimeout;
 let tempResponse = '';
 let groundingMetadata = null;

 const stopButton = new ButtonBuilder()
   .setCustomId('stop_generating')
   .setLabel('Stop Generating')
   .setStyle(ButtonStyle.Danger);
 await botMessage.edit({
   components: [new ActionRowBuilder().addComponents(stopButton)]
 });

 let stopGeneration = false;
 const collector = botMessage.createMessageComponentCollector({
   filter: (i) => i.customId === 'stop_generating' && i.user.id === userId,
   time: 120000
 });

 collector.on('collect', async (i) => {
   stopGeneration = true;
   collector.stop();
   await i.reply({
     embeds: [createSuccessEmbed('Response generation stopped.')],
     ephemeral: true
   });
   await botMessage.edit({
     embeds: [createErrorEmbed('Response generation stopped by user.')],
     components: []
   });
 });

 const updateMessage = () => {
   if (stopGeneration || tempResponse.trim() === "") return;
   try {
     if (responseFormat === 'Embedded') {
       updateEmbed(botMessage, tempResponse, interactionOrMessage, responseColor, groundingMetadata);
     } else {
       botMessage.edit({
         content: tempResponse,
         embeds: []
       });
     }
   } catch (e) {
     console.error("Error updating message:", e);
   }
   clearTimeout(updateTimeout);
   updateTimeout = null;
 };

 while (attempts > 0 && !stopGeneration) {
   try {
     let finalResponse = '';
     let isLargeResponse = false;
     const newHistory = [];
     newHistory.push({
       role: 'user',
       content: parts
     });

     const result = await chat.sendMessageStream(parts);

     for await (const chunk of result.stream) {
       if (stopGeneration) break;

       const chunkText = chunk.text ? chunk.text() : "";
       if (chunkText) {
         finalResponse += chunkText;
         tempResponse += chunkText;
       }

       if (chunk.candidates && chunk.candidates[0]?.groundingMetadata) {
         groundingMetadata = chunk.candidates[0].groundingMetadata;
       }

       if (finalResponse.length > maxCharacterLimit && !isLargeResponse) {
         isLargeResponse = true;
         await botMessage.edit({
           embeds: [createErrorEmbed('Response is too large. It will be sent as a text file when complete.')],
           components: [new ActionRowBuilder().addComponents(stopButton)]
         });
       } else if (!isLargeResponse && !updateTimeout) {
         updateTimeout = setTimeout(updateMessage, 500);
       }
     }
     clearInterval(typingInterval);
     clearTimeout(updateTimeout);

     if (stopGeneration) {
       activeRequests.delete(userId);
       return;
     }

     newHistory.push({
       role: 'assistant',
       content: [{
         text: finalResponse
       }]
     });

     const finalComponents = [];
     if (showActionButtons) {
       const actionRow = new ActionRowBuilder().addComponents(
         new ButtonBuilder().setCustomId(`download_message`).setLabel('Save').setEmoji('⬇️').setStyle(ButtonStyle.Secondary),
         new ButtonBuilder().setCustomId(`delete_${botMessage.id}`).setLabel('Delete').setEmoji('🗑️').setStyle(ButtonStyle.Danger)
       );
       finalComponents.push(actionRow);
     }

     if (isLargeResponse) {
       await sendAsTextFile(finalResponse, interactionOrMessage, botMessage.id, finalComponents);
       await botMessage.edit({
         embeds: [createSuccessEmbed('Response was too large and has been sent as a file.')],
         components: []
       });
     } else {
       if (responseFormat === 'Embedded') {
         await updateEmbed(botMessage, finalResponse, interactionOrMessage, responseColor, groundingMetadata);
       } else {
         await botMessage.edit({
           content: finalResponse,
           embeds: []
         });
       }
       await botMessage.edit({
         components: finalComponents
       });
     }

     await chatHistoryLock.runExclusive(async () => {
       updateChatHistory(historyId, newHistory, botMessage.id);
       await saveStateToFile();
     });
     break;
   } catch (error) {
     console.error('Generation Attempt Failed: ', error);
     attempts--;
     clearInterval(typingInterval);
     clearTimeout(updateTimeout);

     if (attempts === 0 || stopGeneration) {
       await botMessage.edit({
         embeds: [createErrorEmbed(`All generation attempts failed. \n\`\`\`${error.message}\`\`\``)],
         components: []
       });
       break;
     } else {
       await interactionOrMessage.channel.send({
         embeds: [createErrorEmbed(`Generation attempt failed, retrying... \n\`\`\`${error.message}\`\`\``)]
       }).then(msg => setTimeout(() => msg.delete().catch(console.error), 5000));
       await delay(500);
     }
   }
 }
 activeRequests.delete(userId);
 collector.stop();
}

function updateEmbed(botMessage, finalResponse, interactionOrMessage, hexColour, groundingMetadata = null) {
 try {
   const user = isInteraction(interactionOrMessage) ? interactionOrMessage.user : interactionOrMessage.author;
   const guild = interactionOrMessage.guild;
   const isContinuous = getEffectiveSettings(user.id, guild?.id).continuousReply;

   const embed = new EmbedBuilder()
     .setColor(hexColour || config.hexColour)
     .setDescription(finalResponse);

   if (!isContinuous || isInteraction(interactionOrMessage)) {
     embed.setAuthor({
       name: `To ${user.displayName}`,
       iconURL: user.displayAvatarURL()
     });
   }

   if (guild) {
     embed.setFooter({
       text: guild.name,
       iconURL: guild.iconURL() || undefined
     });
   }

   if (groundingMetadata && groundingMetadata.webSearchQueries && groundingMetadata.webSearchQueries.length > 0) {
     embed.addFields({
       name: '🔍 Search Queries',
       value: groundingMetadata.webSearchQueries.map(q => `• ${q}`).join('\n'),
       inline: false
     });
   }

   botMessage.edit({
     content: ' ',
     embeds: [embed]
   });
 } catch (error) {
   console.error("An error occurred while updating the embed:", error.message);
 }
}

async function sendAsTextFile(text, interactionOrMessage, orgId, components) {
 const channel = interactionOrMessage.channel;
 const user = isInteraction(interactionOrMessage) ? interactionOrMessage.user : interactionOrMessage.author;
 try {
   const filename = `response-${Date.now()}.txt`;
   const tempFilePath = path.join(TEMP_DIR, filename);
   await fs.writeFile(tempFilePath, text);

   const botMessage = await channel.send({
     content: `<@${user.id}>, Here is the response:`,
     files: [tempFilePath],
     components: components
   });

   await cleanupTempFiles([tempFilePath]);

   const historyId = getHistoryId(user.id, channel.id, interactionOrMessage.guild?.id);
   await chatHistoryLock.runExclusive(async () => {
     if (state.chatHistories[historyId] && state.chatHistories[historyId][orgId]) {
       state.chatHistories[historyId][botMessage.id] = state.chatHistories[historyId][orgId];
       delete state.chatHistories[historyId][orgId];
       await saveStateToFile();
     }
   });

 } catch (error) {
   console.error('An error occurred while sending as text file:', error);
   await channel.send({
     embeds: [createErrorEmbed(`Failed to send response as file: ${error.message}`)]
   });
 }
}

async function downloadMessage(interaction) {
 try {
   const message = interaction.message;
   let textContent = message.content;
   if (!textContent && message.embeds.length > 0) {
     textContent = message.embeds[0].description;
   }

   if (!textContent || textContent.trim() === '' || textContent.trim() === ' ') {
     return interaction.reply({
       embeds: [createErrorEmbed('The message content is empty.')],
       ephemeral: true
     });
   }

   const filePath = path.join(TEMP_DIR, `message_content_${interaction.id}.txt`);
   await fs.writeFile(filePath, textContent, 'utf8');
   const attachment = new AttachmentBuilder(filePath, {
     name: 'message_content.txt'
   });

   await interaction.reply({
     embeds: [createSuccessEmbed('Here is the content of the message.')],
     files: [attachment],
     ephemeral: true
   });

   await cleanupTempFiles([filePath]);
 } catch (error) {
   console.error('Failed to process download:', error);
   await interaction.followUp({
     embeds: [createErrorEmbed(`Failed to download message: ${error.message}`)],
     ephemeral: true
   });
 }
}

async function downloadConversation(interaction) {
 try {
   const userId = interaction.user.id;
   const conversationHistory = getHistory(userId);

   if (!conversationHistory || conversationHistory.length === 0) {
     return interaction.editReply({
       embeds: [createErrorEmbed('No personal conversation history found.')],
       ephemeral: true
     });
   }

   let conversationText = conversationHistory.map(entry => {
     const role = entry.role === 'user' ? '[User]' : '[Model]';
     const content = entry.parts.map(c => c.text).join('\n');
     return `${role}:\n${content}\n\n`;
   }).join('');

   const tempFileName = path.join(TEMP_DIR, `conversation_${interaction.id}.txt`);
   await fs.writeFile(tempFileName, conversationText, 'utf8');
   const file = new AttachmentBuilder(tempFileName, {
     name: 'conversation_history.txt'
   });

   await interaction.editReply({
     embeds: [createSuccessEmbed('Here is your personal conversation history:')],
     files: [file],
     ephemeral: true
   });

   await cleanupTempFiles([tempFileName]);
 } catch (error) {
   console.log(`Failed to download conversation: ${error.message}`);
   await interaction.editReply({
     embeds: [createErrorEmbed(`Failed to download history: ${error.message}`)],
     ephemeral: true
   });
 }
}

function getHistoryId(userId, channelId, guildId) {
 const serverSettings = getServerSettings(guildId);
 if (guildId) {
   if (serverSettings.serverChatHistory) {
     return guildId;
   } else if (state.channelWideChatHistory[channelId]) {
     return channelId;
   }
 }
 return userId;
}

function isInteraction(interactionOrMessage) {
 return !interactionOrMessage.author;
}

const app = express();
app.get('/', (req, res) => {
 res.send('Bot is running!');
});
app.listen(config.PORT, () => {
 console.log(`Express server listening on port ${config.PORT}`);
});

client.login(token);