// index.js (Over 2400 lines for enhanced functionality)

import {
 MessageFlags,
 ActionRowBuilder,
 ButtonBuilder,
 ButtonStyle,
 ChannelType,
 TextInputBuilder,
 TextInputStyle,
 ModalBuilder,
 PermissionsBitField,
 EmbedBuilder,
 AttachmentBuilder,
 ActivityType,
 ComponentType,
 REST,
 Routes,
 ApplicationCommandOptionType,
 PermissionFlagsBits
} from 'discord.js';
import {
 HarmBlockThreshold,
 HarmCategory
} from '@google/genai';
import fs from 'fs/promises';
import {
 createWriteStream
} from 'fs';
import path from 'path';
import {
 getTextExtractor
} from 'office-text-extractor'
import osu from 'node-os-utils';
const {
 mem,
 cpu
} = osu;
import axios from 'axios';
import express from 'express'; // Added Express

import config from './config.js';
import {
 client,
 genAI,
 createPartFromUri,
 token,
 activeRequests,
 chatHistoryLock,
 state,
 TEMP_DIR,
 initialize,
 saveStateToFile,
 getHistory,
 updateChatHistory,
 getBotPreference, // New preference getter
 initializeBlacklistForGuild
} from './botManager.js';

initialize().catch(console.error);


// <=====[Express Server]=====>

const app = express();
const PORT = process.env.PORT || 3000;
app.get('/', (req, res) => res.send('The Professional Discord Bot is online and running!'));
app.listen(PORT, () => console.log(`HTTP Server listening on port ${PORT}`));

// <==========>


// <=====[Configuration]=====>

// This will now be dynamically set per user/server
const MODEL = "gemini-2.5-flash"; // Default fallback (used only for API init if no preference is found)

const safetySettings = [{
   category: HarmCategory.HARM_CATEGORY_HARASSMENT,
   threshold: HarmBlockThreshold.BLOCK_NONE,
 },
 {
   category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
   threshold: HarmBlockThreshold.BLOCK_NONE,
 },
 {
   category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
   threshold: HarmBlockThreshold.BLOCK_NONE,
 },
 {
   category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
   threshold: HarmBlockThreshold.BLOCK_NONE,
 },
];

const generationConfig = {
 temperature: 1.0,
 topP: 0.95,
 // maxOutputTokens: 1000,
 thinkingConfig: {
   thinkingBudget: -1
 }
};

// Config values moved to config.js and retrieved via getBotPreference
const activities = config.activities.map(activity => ({
 name: activity.name,
 type: ActivityType[activity.type]
}));
const defaultPersonality = config.defaultPersonality;
const workInDMs = config.workInDMs;
const shouldDisplayPersonalityButtons = config.shouldDisplayPersonalityButtons;
const SEND_RETRY_ERRORS_TO_DISCORD = config.SEND_RETRY_ERRORS_TO_DISCORD;


import {
 delay,
 retryOperation,
} from './tools/others.js';

// <==========>


// <=====[Register Commands And Activities]=====>

import {
 commands
} from './commands.js';

let activityIndex = 0;
client.once('ready', async () => {
 console.log(`Logged in as ${client.user.tag}!`);

 const rest = new REST().setToken(token);
 try {
   console.log('Started refreshing application (/) commands.');

   // Only register the two new commands
   await rest.put(
     Routes.applicationCommands(client.user.id), {
       body: commands
     },
   );

   console.log('Successfully reloaded application (/) commands.');
 } catch (error) {
   console.error(error);
 }

 client.user.setPresence({
   activities: [activities[activityIndex]],
   status: 'online', // Changed to online
 });

 setInterval(() => {
   activityIndex = (activityIndex + 1) % activities.length;
   client.user.setPresence({
     activities: [activities[activityIndex]],
     status: 'online',
   });
 }, 30000);
});

// <==========>


// <=====[Messages And Interaction]=====>

client.on('messageCreate', async (message) => {
 try {
   if (message.author.bot) return;

   const isDM = message.channel.type === ChannelType.DM;
   const botMentioned = message.mentions.users.has(client.user.id);
   const hasValidContent = message.content.trim() !== '' || message.attachments.size > 0;

   // Determine if the bot should respond to the message
   const shouldRespond = (
     workInDMs && isDM ||
     state.alwaysRespondChannels[message.channelId] || // legacy channel-wide setting
     (botMentioned && !isDM) ||
     state.activeUsersInChannels[message.channelId]?.[message.author.id] // legacy user opt-in
   );

   if (shouldRespond && hasValidContent) {
     if (message.guild) {
       initializeBlacklistForGuild(message.guild.id);
       if (state.blacklistedUsers[message.guild.id].includes(message.author.id)) {
         const embed = new EmbedBuilder()
           .setColor(0xFF0000)
           .setTitle('Blacklisted')
           .setDescription('You are blacklisted and cannot use this bot.');
         return message.reply({
           embeds: [embed]
         });
       }
     }
     if (activeRequests.has(message.author.id)) {
       const embed = new EmbedBuilder()
         .setColor(0xFFFF00)
         .setTitle('Request In Progress')
         .setDescription('Please wait until your previous action is complete.');
       await message.reply({
         embeds: [embed]
       });
     } else {
       activeRequests.add(message.author.id);
       await handleTextMessage(message);
     }
   }
 } catch (error) {
   console.error('Error processing the message:', error);
   if (activeRequests.has(message.author.id)) {
     activeRequests.delete(message.author.id);
   }
 }
});

client.on('interactionCreate', async (interaction) => {
 try {
   if (interaction.isChatInputCommand()) {
     await handleCommandInteraction(interaction);
   } else if (interaction.isButton()) {
     await handleButtonInteraction(interaction);
   } else if (interaction.isModalSubmit()) {
     await handleModalSubmit(interaction);
   } else if (interaction.isStringSelectMenu()) { // Added select menu handling
     await handleSelectMenuInteraction(interaction);
   }
 } catch (error) {
   console.error('Error handling interaction:', error.message);
 }
});

async function handleCommandInteraction(interaction) {
 if (!interaction.isChatInputCommand()) return;

 const commandHandlers = {
   settings: showSettingsMain, // Unified handler
   search: handleSearchCommand, // New multimodal handler
 };

 const handler = commandHandlers[interaction.commandName];
 if (handler) {
   // Acknowledge interaction immediately for a better user experience
   await interaction.deferReply({
     ephemeral: interaction.commandName === 'settings'
   }).catch(console.error);

   await handler(interaction);
 } else {
   console.log(`Unknown command: ${interaction.commandName}`);
 }
}

async function handleSearchCommand(interaction) {
 const userId = interaction.user.id;
 const prompt = interaction.options.getString('prompt') || '';
 const fileAttachment = interaction.options.getAttachment('file');

 if (!prompt && !fileAttachment) {
   const errorEmbed = new EmbedBuilder()
     .setColor(0xFF0000)
     .setTitle('Multimodal Search Failed')
     .setDescription('You must provide a text prompt or attach a file to use the `/search` command.');
   return interaction.editReply({
     embeds: [errorEmbed],
     ephemeral: true
   });
 }

 // Create a mock message object to reuse handleTextMessage logic
 const mockMessage = {
   content: prompt,
   author: interaction.user,
   channel: interaction.channel,
   guild: interaction.guild,
   attachments: fileAttachment ? new Map([
     [fileAttachment.id, fileAttachment]
   ]) : new Map(),
   reply: (options) => interaction.editReply(options), // Use editReply as the reply method
   delete: () => interaction.deleteReply().catch(() => {}), // Use deleteReply
 };

 // Add mock attachments to mimic messageCreate structure for reuse
 if (fileAttachment) {
   mockMessage.attachments.set(fileAttachment.id, fileAttachment);
 }
 
 if (activeRequests.has(userId)) {
     const embed = new EmbedBuilder()
         .setColor(0xFFFF00)
         .setTitle('Request In Progress')
         .setDescription('Please wait until your previous action is complete.');
     return interaction.editReply({ embeds: [embed] });
 }

 try {
   activeRequests.add(userId);
   // Since we deferred the reply, we need to handle the execution now.
   await handleTextMessage(mockMessage, true); // Pass true to indicate an interaction reply
 } catch (error) {
   console.error('Error in handleSearchCommand:', error);
   const errorEmbed = new EmbedBuilder()
     .setColor(0xFF0000)
     .setTitle('Error During Search')
     .setDescription(`An unexpected error occurred: \`${error.message}\``);
   await interaction.editReply({
     embeds: [errorEmbed]
   }).catch(console.error);
 } finally {
   if (activeRequests.has(userId)) {
       activeRequests.delete(userId);
   }
 }
}

async function handleButtonInteraction(interaction) {
 if (!interaction.isButton()) return;

 // Acknowledge interaction immediately unless it's a stop or delete
 if (!interaction.customId.startsWith('stopGenerating') && !interaction.customId.startsWith('delete_message')) {
   await interaction.deferUpdate().catch(console.error);
 }

 if (interaction.guild) {
   initializeBlacklistForGuild(interaction.guild.id);
   if (state.blacklistedUsers[interaction.guild.id].includes(interaction.user.id)) {
     const embed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('Blacklisted')
       .setDescription('You are blacklisted and cannot use this interaction.');
     return interaction.reply({
       embeds: [embed],
       flags: MessageFlags.Ephemeral
     });
   }
 }

 const buttonHandlers = {
   'settings-user': showUserSettings,
   'settings-server': showServerSettings,
   'back_to_main': showSettingsMain,
   'back_to_user': showUserSettings,
   'back_to_server': showServerSettings,
   'toggle-continuous-reply': toggleContinuousReply,
   'toggle-action-buttons': toggleActionButtons,
   'set-model': showModelSelector,
   'set-color': showColorModal,
   'clear-memory': handleClearMemoryCommand,
   'download-history': downloadConversation,
   'custom-personality': setCustomPersonality,
   'remove-personality': removeCustomPersonality,
   'toggle-response-mode': toggleUserResponsePreference,
   'download_message': downloadMessage,
   'toggle-server-history': toggleServerWideChatHistory,
   'clear-server-memory': clearServerChatHistory,
   'set-server-personality': serverPersonalityModal,
   'remove-server-personality': removeServerPersonality,
   'toggle-server-personality-mode': toggleServerPersonalityMode,
   'toggle-server-response-mode': toggleServerResponsePreference,
   'toggle-server-override': toggleServerOverride,
 };


 for (const [key, handler] of Object.entries(buttonHandlers)) {
   if (interaction.customId.startsWith(key)) {
     await handler(interaction);
     return;
   }
 }

 if (interaction.customId.startsWith('delete_message-')) {
   const msgId = interaction.customId.replace('delete_message-', '');
   await handleDeleteMessageInteraction(interaction, msgId);
 }
}

async function handleSelectMenuInteraction(interaction) {
 if (interaction.customId === 'model-selector-menu') {
   const selectedModel = interaction.values[0];
   state.userModelPreference[interaction.user.id] = selectedModel;

   const successEmbed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Model Updated')
     .setDescription(`Your preferred model has been set to: **${selectedModel}**.`);

   await interaction.update({
     embeds: [successEmbed],
     components: [],
     flags: MessageFlags.Ephemeral
   });
   // Re-show settings after success
   await showUserSettings(interaction, true);

 } else if (interaction.customId === 'server-model-selector-menu') {
   if (!interaction.memberPermissions.has(PermissionFlagsBits.ManageGuild)) {
     return interaction.reply({
       content: 'You need the **Manage Server** permission to change server settings.',
       ephemeral: true
     });
   }

   const selectedModel = interaction.values[0];
   initializeBlacklistForGuild(interaction.guild.id);
   state.serverSettings[interaction.guild.id].modelPreference = selectedModel;
   await saveStateToFile();

   const successEmbed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Server Model Updated')
     .setDescription(`The server's default model has been set to: **${selectedModel}**.`);

   await interaction.update({
     embeds: [successEmbed],
     components: [],
     flags: MessageFlags.Ephemeral
   });
   // Re-show settings after success
   await showServerSettings(interaction, true);
 }
}

async function handleModalSubmit(interaction) {
 if (interaction.customId === 'custom-personality-modal') {
   const customInstructionsInput = interaction.fields.getTextInputValue('custom-personality-input');
   state.customInstructions[interaction.user.id] = customInstructionsInput.trim();
   await saveStateToFile();

   const embed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Success')
     .setDescription('Custom Personality Instructions Saved!');
   await interaction.reply({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
   await showUserSettings(interaction, true); // Update settings view

 } else if (interaction.customId === 'custom-server-personality-modal') {
   if (!interaction.memberPermissions.has(PermissionFlagsBits.ManageGuild)) {
     return interaction.reply({
       content: 'You need the **Manage Server** permission to change server settings.',
       ephemeral: true
     });
   }

   const customInstructionsInput = interaction.fields.getTextInputValue('custom-server-personality-input');
   state.customInstructions[interaction.guild.id] = customInstructionsInput.trim();
   await saveStateToFile();

   const embed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Success')
     .setDescription('Custom Server Personality Instructions Saved!');
   await interaction.reply({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
   await showServerSettings(interaction, true); // Update settings view

 } else if (interaction.customId === 'color-input-modal') {
   const hexInput = interaction.fields.getTextInputValue('color-hex-input');
   if (!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hexInput)) {
     const errorEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('Invalid Hex Code')
       .setDescription('Please enter a valid hex color code (e.g., #007ACC or #333).');
     return interaction.reply({
       embeds: [errorEmbed],
       flags: MessageFlags.Ephemeral
     });
   }
   state.userResponseColor[interaction.user.id] = hexInput.toUpperCase();
   await saveStateToFile();
   
   const embed = new EmbedBuilder()
     .setColor(hexInput)
     .setTitle('Success')
     .setDescription(`Response Embed Color set to: **${hexInput.toUpperCase()}**`);
   await interaction.reply({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
   await showUserSettings(interaction, true); // Update settings view

 } else if (interaction.customId === 'server-color-input-modal') {
   if (!interaction.memberPermissions.has(PermissionFlagsBits.ManageGuild)) {
     return interaction.reply({
       content: 'You need the **Manage Server** permission to change server settings.',
       ephemeral: true
     });
   }

   const hexInput = interaction.fields.getTextInputValue('server-color-hex-input');
   if (!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hexInput)) {
     const errorEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('Invalid Hex Code')
       .setDescription('Please enter a valid hex color code (e.g., #007ACC or #333).');
     return interaction.reply({
       embeds: [errorEmbed],
       flags: MessageFlags.Ephemeral
     });
   }
   initializeBlacklistForGuild(interaction.guild.id);
   state.serverSettings[interaction.guild.id].responseColor = hexInput.toUpperCase();
   await saveStateToFile();
   
   const embed = new EmbedBuilder()
     .setColor(hexInput)
     .setTitle('Success')
     .setDescription(`Server Response Embed Color set to: **${hexInput.toUpperCase()}**`);
   await interaction.reply({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
   await showServerSettings(interaction, true); // Update settings view
 }
}

// Replaced handleTextMessage with a more robust version below.
// Replaced handleDeleteMessageInteraction with the one below.
// Replaced handleClearMemoryCommand with a simplified version below.
// Removed all old command handlers: handleRespondToAllCommand, toggleChannelChatHistory, handleStatusCommand, handleBlacklistCommand, handleWhitelistCommand.
// Removed most old button handlers, keeping only the ones related to new settings UI.


// <=====[New Settings UI and Handlers]=====>

// --- Helper Functions ---

function getActionButtonsStatus(interaction) {
   const guildId = interaction.guild?.id;
   const userId = interaction.user.id;
   return getBotPreference(guildId, userId, 'actionButtons', config.defaultActionButtons);
}

function getModel(guildId, userId) {
   return getBotPreference(guildId, userId, 'modelPreference', config.defaultModel);
}

function getColor(guildId, userId) {
   return getBotPreference(guildId, userId, 'responseColor', config.defaultResponseColor);
}

function getResponseStyle(guildId, userId) {
   // Legacy mapping: userResponsePreference (Embedded/Normal) maps to 'responseStyle'
   // Server has a responseStyle property, but user still uses userResponsePreference.
   return getBotPreference(guildId, userId, 'responseStyle', config.defaultResponseFormat);
}

function getContinuousReplyStatus(guildId, userId) {
   return getBotPreference(guildId, userId, 'continuousReply', config.defaultContinuousReply);
}

function hasManageServer(interaction) {
   return interaction.guild && interaction.memberPermissions.has(PermissionFlagsBits.ManageGuild);
}

// --- Main Settings Interface ---

async function showSettingsMain(interaction, edit = false) {
 const guildId = interaction.guild?.id;
 const userId = interaction.user.id;

 if (guildId) {
   initializeBlacklistForGuild(guildId);
 }

 const userModel = getModel(guildId, userId);
 const userColor = getColor(guildId, userId);

 const embed = new EmbedBuilder()
   .setColor(userColor)
   .setTitle('⚙️ Bot Configuration Interface')
   .setDescription(`Welcome to the enhanced settings panel. Your current model preference is **${userModel}**.`)
   .addFields(
     { name: '👤 User Settings', value: 'Customize the bot\'s behavior, model, and appearance specifically for you.', inline: true },
     { name: '🏢 Server Settings', value: 'Adjust configurations that affect everyone in this server (requires **Manage Server** permission).', inline: true }
   )
   .setFooter({ text: 'Changes saved automatically upon selection.' });

 const buttons = [
   new ButtonBuilder()
   .setCustomId('settings-user')
   .setLabel('User Settings')
   .setEmoji('👤')
   .setStyle(ButtonStyle.Primary),
   new ButtonBuilder()
   .setCustomId('settings-server')
   .setLabel('Server Settings')
   .setEmoji('🏢')
   .setStyle(ButtonStyle.Secondary)
   .setDisabled(!interaction.guild) // Disable if in DM
 ];

 const actionRow = new ActionRowBuilder().addComponents(buttons);

 if (edit) {
   await interaction.editReply({
     embeds: [embed],
     components: [actionRow],
     flags: MessageFlags.Ephemeral // Ensure it stays ephemeral
   });
 } else {
   // If called from an interaction (like /settings), this will be the reply.
   // If called from a button (like back_to_main), it's handled by deferUpdate/editReply in handleButtonInteraction.
   await interaction.editReply({
     embeds: [embed],
     components: [actionRow],
     flags: MessageFlags.Ephemeral
   });
 }
}

// --- User Settings Interface ---

async function showUserSettings(interaction, update = false) {
 const guildId = interaction.guild?.id;
 const userId = interaction.user.id;
 
 const userModel = getModel(guildId, userId);
 const userColor = getColor(guildId, userId);
 const continuousReply = getContinuousReplyStatus(guildId, userId);
 const responseStyle = getResponseStyle(guildId, userId);
 const actionButtons = getActionButtonsStatus(guildId, userId);
 const customPersonality = state.customInstructions[userId] ? 'SET' : 'NONE';
 
 const serverOverrideEnabled = guildId && state.serverSettings[guildId].overrideEnabled;
 let overrideMessage = '';
 if (serverOverrideEnabled) {
     overrideMessage = '\n\n**⚠️ Server Override is ACTIVE!** Your local settings may be ignored.';
 }

 const embed = new EmbedBuilder()
   .setColor(userColor)
   .setTitle('👤 Your Personal Settings')
   .setDescription(`Configure the bot's behavior for you across all interactions.${overrideMessage}`)
   .addFields(
     { name: '🤖 Model', value: `Current: **${userModel}**`, inline: true },
     { name: '💬 Continuous Reply (No Mention)', value: `Status: **${continuousReply ? 'ON' : 'OFF'}**`, inline: true },
     { name: '🎨 Embed Style', value: `Current: **${responseStyle}**, Color: **${userColor}**`, inline: true },
     { name: '📌 Action Buttons (Save/Stop/Delete)', value: `Status: **${actionButtons ? 'SHOW' : 'HIDE'}**`, inline: true },
     { name: '🧠 Personality', value: `Custom Instructions: **${customPersonality}**`, inline: true },
     { name: '🗃️ History', value: 'Manage your personal chat logs.', inline: true }
   )
   .setFooter({ text: 'Click a button to change the setting.' });

 const row1 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('set-model').setLabel('Model Selector').setEmoji('🤖').setStyle(ButtonStyle.Secondary),
   new ButtonBuilder().setCustomId('toggle-continuous-reply').setLabel(`Continuous Reply: ${continuousReply ? 'ON' : 'OFF'}`).setEmoji('💬').setStyle(continuousReply ? ButtonStyle.Success : ButtonStyle.Danger),
   new ButtonBuilder().setCustomId('toggle-response-mode').setLabel(`Response Format: ${responseStyle}`).setEmoji('📝').setStyle(ButtonStyle.Secondary),
 );
 
 const row2 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('set-color').setLabel('Set Embed Color').setEmoji('🎨').setStyle(ButtonStyle.Secondary),
   new ButtonBuilder().setCustomId('toggle-action-buttons').setLabel(`Action Buttons: ${actionButtons ? 'SHOW' : 'HIDE'}`).setEmoji('📌').setStyle(actionButtons ? ButtonStyle.Success : ButtonStyle.Danger),
   new ButtonBuilder().setCustomId('custom-personality').setLabel('Set Personality').setEmoji('🧠').setStyle(ButtonStyle.Primary),
   new ButtonBuilder().setCustomId('remove-personality').setLabel('Clear Personality').setEmoji('🗑️').setStyle(ButtonStyle.Danger).setDisabled(customPersonality === 'NONE'),
 );

 const row3 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('clear-memory').setLabel('Clear History').setEmoji('🧹').setStyle(ButtonStyle.Danger),
   new ButtonBuilder().setCustomId('download-history').setLabel('Download History').setEmoji('🗃️').setStyle(ButtonStyle.Secondary),
   new ButtonBuilder().setCustomId('back_to_main').setLabel('Back to Main').setEmoji('🔙').setStyle(ButtonStyle.Secondary),
 );

 await interaction.editReply({
   embeds: [embed],
   components: [row1, row2, row3],
   flags: MessageFlags.Ephemeral
 });
}

// --- Server Settings Interface ---

async function showServerSettings(interaction, update = false) {
 if (!interaction.guild) return;
 if (!hasManageServer(interaction)) {
     const errorEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('Permission Denied')
       .setDescription('You must have the **Manage Server** permission to access these settings.');
     return interaction.editReply({ embeds: [errorEmbed], components: [] });
 }

 const guildId = interaction.guild.id;
 initializeBlacklistForGuild(guildId);
 const serverSettings = state.serverSettings[guildId];

 const embed = new EmbedBuilder()
   .setColor(serverSettings.responseColor)
   .setTitle(`🏢 ${interaction.guild.name} Server Settings`)
   .setDescription('These settings apply to all users in this server unless overridden.')
   .addFields(
     { name: 'Override User Settings', value: `Status: **${serverSettings.overrideEnabled ? 'ACTIVE' : 'INACTIVE'}**`, inline: true },
     { name: 'Model Preference', value: `Current: **${serverSettings.modelPreference}**`, inline: true },
     { name: 'Continuous Reply', value: `Status: **${serverSettings.continuousReply ? 'ON' : 'OFF'}**`, inline: true },
     { name: 'Server Personality', value: `Status: **${serverSettings.customServerPersonality ? 'ACTIVE' : 'INACTIVE'}**`, inline: true },
     { name: 'Response Format', value: `Style: **${serverSettings.responseStyle}**, Color: **${serverSettings.responseColor}**`, inline: true },
     { name: 'Action Buttons', value: `Status: **${serverSettings.actionButtons ? 'SHOW' : 'HIDE'}**`, inline: true },
     { name: 'Chat History', value: `Server-Wide History: **${serverSettings.serverChatHistory ? 'ON' : 'OFF'}**`, inline: true }
   )
   .setFooter({ text: 'Changes saved automatically upon selection.' });

 const row1 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('toggle-server-override').setLabel(`Override User Settings: ${serverSettings.overrideEnabled ? 'ON' : 'OFF'}`).setEmoji('⚠️').setStyle(serverSettings.overrideEnabled ? ButtonStyle.Success : ButtonStyle.Danger),
   new ButtonBuilder().setCustomId('set-server-model').setLabel('Model Selector').setEmoji('🤖').setStyle(ButtonStyle.Secondary),
   new ButtonBuilder().setCustomId('toggle-continuous-reply-server').setLabel(`Continuous Reply: ${serverSettings.continuousReply ? 'ON' : 'OFF'}`).setEmoji('💬').setStyle(serverSettings.continuousReply ? ButtonStyle.Success : ButtonStyle.Danger),
 );

 const row2 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('toggle-server-personality-mode').setLabel(`Toggle Personality: ${serverSettings.customServerPersonality ? 'ON' : 'OFF'}`).setEmoji('🧠').setStyle(serverSettings.customServerPersonality ? ButtonStyle.Success : ButtonStyle.Danger),
   new ButtonBuilder().setCustomId('set-server-personality').setLabel('Set Personality').setEmoji('✏️').setStyle(ButtonStyle.Primary),
   new ButtonBuilder().setCustomId('remove-server-personality').setLabel('Clear Personality').setEmoji('🗑️').setStyle(ButtonStyle.Danger).setDisabled(!state.customInstructions[guildId]),
 );

 const row3 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('toggle-server-response-mode').setLabel(`Response Format: ${serverSettings.responseStyle}`).setEmoji('📝').setStyle(ButtonStyle.Secondary),
   new ButtonBuilder().setCustomId('set-server-color').setLabel('Set Embed Color').setEmoji('🎨').setStyle(ButtonStyle.Secondary),
   new ButtonBuilder().setCustomId('toggle-server-buttons').setLabel(`Action Buttons: ${serverSettings.actionButtons ? 'SHOW' : 'HIDE'}`).setEmoji('📌').setStyle(serverSettings.actionButtons ? ButtonStyle.Success : ButtonStyle.Danger),
 );

 const row4 = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('toggle-server-history').setLabel(`Server History: ${serverSettings.serverChatHistory ? 'ON' : 'OFF'}`).setEmoji('📦').setStyle(serverSettings.serverChatHistory ? ButtonStyle.Success : ButtonStyle.Danger),
   new ButtonBuilder().setCustomId('clear-server-memory').setLabel('Clear Server History').setEmoji('🧹').setStyle(ButtonStyle.Danger).setDisabled(!serverSettings.serverChatHistory),
   new ButtonBuilder().setCustomId('download-server-history').setLabel('Download Server History').setEmoji('🗃️').setStyle(ButtonStyle.Secondary).setDisabled(!serverSettings.serverChatHistory),
   new ButtonBuilder().setCustomId('back_to_main').setLabel('Back to Main').setEmoji('🔙').setStyle(ButtonStyle.Secondary),
 );

 await interaction.editReply({
   embeds: [embed],
   components: [row1, row2, row3, row4],
   flags: MessageFlags.Ephemeral
 });
}

// --- Specific Setting Modals/Handlers ---

async function showModelSelector(interaction) {
 const selectMenu = new SelectMenuBuilder()
   .setCustomId('model-selector-menu')
   .setPlaceholder('Select a Gemini Model')
   .addOptions([{
       label: 'Gemini 2.5 Flash (Default, Fast, Multimodal)',
       value: 'gemini-2.5-flash',
     },
     {
       label: 'Gemini 2.5 Flash Lite (Faster, Text-Optimized)',
       value: 'gemini-2.5-flash-lite',
     },
     {
       label: 'Gemini 2.0 Flash (Legacy, Multimodal)',
       value: 'gemini-2.0-flash',
     }
   ]);

 const actionRow = new ActionRowBuilder().addComponents(selectMenu);
 
 await interaction.editReply({
     embeds: [
         new EmbedBuilder()
         .setColor(getColor(interaction.guild?.id, interaction.user.id))
         .setTitle('🤖 Model Selector')
         .setDescription('Choose your preferred Gemini model for interactions.')
     ],
     components: [actionRow],
     flags: MessageFlags.Ephemeral
 });
}

async function showColorModal(interaction) {
 const colorInput = new TextInputBuilder()
   .setCustomId('color-hex-input')
   .setLabel("Enter new Embed Hex Color (e.g., #007ACC)")
   .setStyle(TextInputStyle.Short)
   .setPlaceholder(getColor(interaction.guild?.id, interaction.user.id))
   .setMaxLength(7);

 const modal = new ModalBuilder()
   .setCustomId('color-input-modal')
   .setTitle('Set Custom Embed Color')
   .addComponents(new ActionRowBuilder().addComponents(colorInput));

 await interaction.showModal(modal);
}

// Handlers for toggles
async function toggleContinuousReply(interaction) {
   const userId = interaction.user.id;
   const current = getBotPreference(interaction.guild?.id, userId, 'continuousReply', config.defaultContinuousReply);
   state.userContinuousReply[userId] = !current;
   await saveStateToFile();
   await showUserSettings(interaction, true);
}

async function toggleActionButtons(interaction) {
   const userId = interaction.user.id;
   const current = getBotPreference(interaction.guild?.id, userId, 'actionButtons', config.defaultActionButtons);
   state.userActionButtons[userId] = !current;
   await saveStateToFile();
   await showUserSettings(interaction, true);
}

// Server Toggles
async function toggleServerOverride(interaction) {
   if (!hasManageServer(interaction)) return;
   const guildId = interaction.guild.id;
   initializeBlacklistForGuild(guildId);
   const current = state.serverSettings[guildId].overrideEnabled;
   state.serverSettings[guildId].overrideEnabled = !current;
   await saveStateToFile();

   const overrideMessage = !current 
       ? 'Server settings are now **ACTIVE** and will override user preferences.'
       : 'Server settings are now **INACTIVE**. Users can use their personal preferences.';
   
   await interaction.channel.send({
       embeds: [new EmbedBuilder().setColor(!current ? 0x00FF00 : 0xFF0000).setTitle('Server Override Status').setDescription(overrideMessage)]
   }).catch(console.error);
   
   await showServerSettings(interaction, true);
}

async function toggleContinuousReplyServer(interaction) {
   if (!hasManageServer(interaction)) return;
   const guildId = interaction.guild.id;
   initializeBlacklistForGuild(guildId);
   state.serverSettings[guildId].continuousReply = !state.serverSettings[guildId].continuousReply;
   await saveStateToFile();
   await showServerSettings(interaction, true);
}

async function toggleActionButtonsServer(interaction) {
   if (!hasManageServer(interaction)) return;
   const guildId = interaction.guild.id;
   initializeBlacklistForGuild(guildId);
   state.serverSettings[guildId].actionButtons = !state.serverSettings[guildId].actionButtons;
   await saveStateToFile();
   await showServerSettings(interaction, true);
}

async function toggleServerPersonalityMode(interaction) {
   if (!hasManageServer(interaction)) return;
   const guildId = interaction.guild.id;
   initializeBlacklistForGuild(guildId);
   state.serverSettings[guildId].customServerPersonality = !state.serverSettings[guildId].customServerPersonality;
   await saveStateToFile();
   await showServerSettings(interaction, true);
}

async function toggleServerResponsePreference(interaction) {
   if (!hasManageServer(interaction)) return;
   const guildId = interaction.guild.id;
   initializeBlacklistForGuild(guildId);
   const current = state.serverSettings[guildId].responseStyle;
   state.serverSettings[guildId].responseStyle = current === 'Embedded' ? 'Normal' : 'Embedded';
   await saveStateToFile();
   await showServerSettings(interaction, true);
}

async function toggleServerWideChatHistory(interaction) {
   if (!hasManageServer(interaction)) return;
   const guildId = interaction.guild.id;
   initializeBlacklistForGuild(guildId);
   state.serverSettings[guildId].serverChatHistory = !state.serverSettings[guildId].serverChatHistory;
   await saveStateToFile();
   await showServerSettings(interaction, true);
}

async function serverPersonalityModal(interaction) {
   if (!hasManageServer(interaction)) return;

   const customId = 'custom-server-personality-input';
   const title = 'Enter Custom Server Personality Instructions';

   const input = new TextInputBuilder()
       .setCustomId(customId)
       .setLabel("What should the bot's server personality be like?")
       .setStyle(TextInputStyle.Paragraph)
       .setPlaceholder("Enter the custom instructions here...")
       .setMinLength(10)
       .setMaxLength(4000);

   const modal = new ModalBuilder()
       .setCustomId('custom-server-personality-modal')
       .setTitle(title)
       .addComponents(new ActionRowBuilder().addComponents(input));

   await interaction.showModal(modal);
}

async function removeServerPersonality(interaction) {
   if (!hasManageServer(interaction)) return;
   const guildId = interaction.guild.id;
   delete state.customInstructions[guildId];
   await saveStateToFile();
   await showServerSettings(interaction, true);
}

// --- History and Personality Handlers (Modified) ---

async function handleClearMemoryCommand(interaction) {
 try {
   const userId = interaction.user.id;
   // Note: The /settings flow is ephemeral, so we need a separate reply.
   state.chatHistories[userId] = {};
   await saveStateToFile();
   
   const embed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Chat History Cleared')
     .setDescription('Your personal chat history cleared!');
   await interaction.followUp({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
   // Update the settings view after action
   await showUserSettings(interaction, true);
 } catch (error) {
   console.log(error.message);
 }
}

async function clearServerChatHistory(interaction) {
   if (!hasManageServer(interaction)) return;
   const guildId = interaction.guild.id;
   if (state.serverSettings[guildId].serverChatHistory) {
     state.chatHistories[guildId] = {};
     await saveStateToFile();
     
     const embed = new EmbedBuilder()
       .setColor(0x00FF00)
       .setTitle('Chat History Cleared')
       .setDescription('Server-wide chat history cleared!');
     await interaction.followUp({
       embeds: [embed],
       flags: MessageFlags.Ephemeral
     });
     // Update the settings view after action
     await showServerSettings(interaction, true);
   }
}

async function setCustomPersonality(interaction) {
 const customId = 'custom-personality-input';
 const title = 'Enter Custom Personality Instructions';

 const input = new TextInputBuilder()
   .setCustomId(customId)
   .setLabel("What should the bot's personality be like?")
   .setStyle(TextInputStyle.Paragraph)
   .setPlaceholder(state.customInstructions[interaction.user.id] || config.defaultPersonality)
   .setMinLength(10)
   .setMaxLength(4000);

 const modal = new ModalBuilder()
   .setCustomId('custom-personality-modal')
   .setTitle(title)
   .addComponents(new ActionRowBuilder().addComponents(input));

 await interaction.showModal(modal);
}

async function removeCustomPersonality(interaction) {
 try {
   delete state.customInstructions[interaction.user.id];
   await saveStateToFile();
   
   const embed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Removed')
     .setDescription('Custom personality instructions removed!');

   await interaction.followUp({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
   // Update the settings view after action
   await showUserSettings(interaction, true);
 } catch (error) {
   console.log(error.message);
 }
}

async function toggleUserResponsePreference(interaction) {
 try {
   const userId = interaction.user.id;
   const currentPreference = getResponseStyle(interaction.guild?.id, userId);
   state.userResponsePreference[userId] = currentPreference === 'Normal' ? 'Embedded' : 'Normal';
   await saveStateToFile();
   await showUserSettings(interaction, true);
 } catch (error) {
   console.log(error.message);
 }
}

// Download handlers are kept but updated to use followUp for ephemeral interactions

async function downloadConversation(interaction) {
 try {
   const userId = interaction.user.id;
   const conversationHistory = getHistory(userId);

   if (!conversationHistory || conversationHistory.length === 0) {
     const noHistoryEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('No History Found')
       .setDescription('No conversation history found.');
     await interaction.followUp({
       embeds: [noHistoryEmbed],
       flags: MessageFlags.Ephemeral
     });
     return;
   }

   let conversationText = conversationHistory.map(entry => {
     const role = entry.role === 'user' ? '[User]' : '[Model]';
     const content = entry.parts.map(c => c.text).join('\n');
     return `${role}:\n${content}\n\n`;
   }).join('');

   const tempFileName = path.join(TEMP_DIR, `conversation_${interaction.id}.txt`);
   await fs.writeFile(tempFileName, conversationText, 'utf8');

   const file = new AttachmentBuilder(tempFileName, {
     name: 'conversation_history.txt'
   });

   try {
     await interaction.user.send({
       content: `> \`Here's your conversation history for ${interaction.user.tag}:\``,
       files: [file]
     });
     const dmSentEmbed = new EmbedBuilder()
       .setColor(0x00FF00)
       .setTitle('History Sent')
       .setDescription('Your conversation history has been sent to your DMs.');
     await interaction.followUp({
       embeds: [dmSentEmbed],
       flags: MessageFlags.Ephemeral
     });
   } catch (error) {
     console.error(`Failed to send DM: ${error}`);
     const failDMEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('Delivery Failed')
       .setDescription('Failed to send the conversation history to your DMs. Check your privacy settings.');
     await interaction.followUp({
       embeds: [failDMEmbed],
       files: [file],
       flags: MessageFlags.Ephemeral
     });
   } finally {
     await fs.unlink(tempFileName);
   }
 } catch (error) {
   console.log(`Failed to download conversation: ${error.message}`);
 }
}

async function downloadServerConversation(interaction) {
   if (!hasManageServer(interaction)) return;
   try {
       const guildId = interaction.guild.id;
       const conversationHistory = getHistory(guildId);

       if (!conversationHistory || conversationHistory.length === 0) {
           const noHistoryEmbed = new EmbedBuilder()
               .setColor(0xFF0000)
               .setTitle('No History Found')
               .setDescription('No server-wide conversation history found.');
           await interaction.followUp({
               embeds: [noHistoryEmbed],
               flags: MessageFlags.Ephemeral
           });
           return;
       }

       const conversationText = conversationHistory.map(entry => {
           const role = entry.role === 'user' ? '[User]' : '[Model]';
           const content = entry.parts.map(c => c.text).join('\n');
           return `${role}:\n${content}\n\n`;
       }).join('');

       const tempFileName = path.join(TEMP_DIR, `server_conversation_${interaction.id}.txt`);
       await fs.writeFile(tempFileName, conversationText, 'utf8');

       const file = new AttachmentBuilder(tempFileName, {
           name: 'server_conversation_history.txt'
       });

       try {
           await interaction.user.send({
               content: `> \`Here's the server-wide conversation history for ${interaction.guild.name}:\``,
               files: [file]
           });
           const dmSentEmbed = new EmbedBuilder()
               .setColor(0x00FF00)
               .setTitle('History Sent')
               .setDescription('Server-wide conversation history has been sent to your DMs.');
           await interaction.followUp({
               embeds: [dmSentEmbed],
               flags: MessageFlags.Ephemeral
           });
       } catch (error) {
           console.error(`Failed to send DM: ${error}`);
           const failDMEmbed = new EmbedBuilder()
               .setColor(0xFF0000)
               .setTitle('Delivery Failed')
               .setDescription('Failed to send the server-wide conversation history to your DMs.');
           await interaction.followUp({
               embeds: [failDMEmbed],
               files: [file],
               flags: MessageFlags.Ephemeral
           });
       } finally {
           await fs.unlink(tempFileName);
       }
   } catch (error) {
       console.log(`Failed to download server conversation: ${error.message}`);
   }
}

// <==========>


// <=====[Messages Handling (Re-factored)]=====>

async function handleTextMessage(message, isInteraction = false) {
 const botId = client.user.id;
 const userId = message.author.id;
 const guildId = message.guild?.id;
 const channelId = message.channel.id;

 let messageContent = message.content.replace(new RegExp(`<@!?${botId}>`), '').trim();
 
 // Dynamic Configuration Retrieval
 const modelPreference = getModel(guildId, userId);
 const continuousReply = getContinuousReplyStatus(guildId, userId);
 const responseColor = getColor(guildId, userId);
 const responseStyle = getResponseStyle(guildId, userId);
 const actionButtons = getActionButtonsStatus(guildId, userId);

 // Initial feedback/typing indication
 if (!isInteraction) {
   message.channel.sendTyping();
 }
 const typingInterval = setInterval(() => {
   message.channel.sendTyping();
 }, 4000);
 setTimeout(() => {
   clearInterval(typingInterval);
 }, 120000);
 
 let botMessage = false;
 let parts;
 let hasText = messageContent.length > 0;
 let hasMedia = message.attachments.size > 0 && hasSupportedAttachments(message);

 try {
   // --- Step 1: Send Initial Processing Embed/Reply ---
   const updateEmbedDescription = (textAttachmentStatus, mediaAttachmentStatus, finalText = '') => {
       return `Let me think...\n\n- ${textAttachmentStatus} Text/Document Check\n- ${mediaAttachmentStatus} Media Attachment Check\n${finalText}`;
   };

   const initialEmbed = new EmbedBuilder()
       .setColor(0x00FFFF)
       .setTitle('Processing Request')
       .setDescription(updateEmbedDescription(hasText ? '[🔁]' : '[✅]', hasMedia ? '[🔁]' : '[✅]'));

   if (isInteraction) {
       // Since the interaction was deferred, this is the first visible message.
       botMessage = await message.reply({ embeds: [initialEmbed], content: ' ' }); 
   } else if (SEND_RETRY_ERRORS_TO_DISCORD) {
       // For standard messages, send a new reply with the processing embed
       clearInterval(typingInterval);
       botMessage = await message.reply({ embeds: [initialEmbed], content: ' ' });
   }
   
   // Fallback: If no botMessage yet, but we need to track a request
   if (!botMessage && !isInteraction) {
       // Send a simple 'thinking' message that can be edited later
       botMessage = await message.reply({ content: 'Thinking...' });
   }

   // --- Step 2: Extract Text Attachments ---
   messageContent = await extractFileText(message, messageContent);
   hasText = messageContent.length > 0; // Update status after extraction

   if (botMessage && SEND_RETRY_ERRORS_TO_DISCORD) {
       initialEmbed.setDescription(updateEmbedDescription('[✅]', hasMedia ? '[🔁]' : '[✅]'));
       await botMessage.edit({ embeds: [initialEmbed] }).catch(console.error);
   }
   
   // --- Step 3: Process Media Attachments ---
   parts = await processPromptAndMediaAttachments(messageContent, message, botMessage);
   
   if (botMessage && SEND_RETRY_ERRORS_TO_DISCORD) {
       initialEmbed.setDescription(updateEmbedDescription('[✅]', '[✅]', '### All attachments processed. Waiting for model response...'));
       await botMessage.edit({ embeds: [initialEmbed] }).catch(console.error);
   }

 } catch (error) {
   if (activeRequests.has(userId)) { activeRequests.delete(userId); }
   console.error('Error during message initialisation/attachment processing:', error);
   
   const errorEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('Processing Error')
       .setDescription(`Could not process your request: \`${error.message}\``);

   if (botMessage) {
       botMessage.edit({ embeds: [errorEmbed], content: `<@${userId}>` }).catch(console.error);
   } else {
       message.channel.send({ embeds: [errorEmbed], content: `<@${userId}>` }).catch(console.error);
   }
   clearInterval(typingInterval);
   return;
 }
 
 // --- Step 4: Determine Instructions and History ID ---
 let finalInstructions;
 let instructionsSource = 'Default';

 if (guildId) {
   const serverSettings = state.serverSettings[guildId];
   
   // 1. Channel-Wide (highest priority for channel-specific instructions)
   if (state.channelWideChatHistory[channelId] && state.customInstructions[channelId]) {
     finalInstructions = state.customInstructions[channelId];
     instructionsSource = 'Channel';
   // 2. Server-Wide Personality (next priority)
   } else if (serverSettings?.customServerPersonality && state.customInstructions[guildId]) {
     finalInstructions = state.customInstructions[guildId];
     instructionsSource = 'Server';
   // 3. User Custom Personality
   } else if (state.customInstructions[userId]) {
     finalInstructions = state.customInstructions[userId];
     instructionsSource = 'User';
   // 4. Fallback to Default
   } else {
     finalInstructions = defaultPersonality;
   }
 } else {
   // DM: User Custom Personality or Default
   finalInstructions = state.customInstructions[userId] || defaultPersonality;
 }
 
 // Add userInfo context only if in a guild
 let infoStr = '';
 if (guildId) {
   const userInfo = {
     username: message.author.username,
     displayName: message.member?.displayName || message.author.displayName
   };
   infoStr = `\nYou are currently engaging with users in the ${message.guild.name} Discord server. You should adopt the tone and personality set for the ${instructionsSource} scope.\n\n## Current User Information\nUsername: \`${userInfo.username}\`\nDisplay Name: \`${userInfo.displayName}\``;
 }

 // Determine History ID
 const isServerChatHistoryEnabled = guildId ? state.serverSettings[guildId]?.serverChatHistory : false;
 const isChannelChatHistoryEnabled = guildId ? state.channelWideChatHistory[channelId] : false;
 
 let historyId;
 if (isServerChatHistoryEnabled) {
     historyId = guildId;
 } else if (isChannelChatHistoryEnabled) {
     historyId = channelId;
 } else {
     historyId = userId;
 }

 finalInstructions = finalInstructions + infoStr;


 // --- Step 5: Initialize Chat and Handle Response ---
 
 // Always enable all three tools: Google Search, URL Context, and Code Execution
 const tools = [
   { googleSearch: {} },
   { urlContext: {} },
   { codeExecution: {} }
 ];

 // Create chat with dynamic model
 const chat = genAI.chats.create({
   model: modelPreference,
   config: {
     systemInstruction: {
       role: "system",
       parts: [{ text: finalInstructions }]
     },
     ...generationConfig,
     safetySettings,
     tools
   },
   history: getHistory(historyId)
 });

 await handleModelResponse(botMessage, chat, parts, message, typingInterval, historyId, continuousReply, responseColor, responseStyle, actionButtons);
}

function hasSupportedAttachments(message) {
 const supportedFileExtensions = ['.html', '.js', '.css', '.json', '.xml', '.csv', '.py', '.java', '.sql', '.log', '.md', '.txt', '.docx', '.pptx', '.pdf'];

 return message.attachments.some((attachment) => {
   const contentType = (attachment.contentType || "").toLowerCase();
   const fileExtension = path.extname(attachment.name) || '';
   return (
     contentType.startsWith('image/') || // Includes GIFs (which the model can process)
     contentType.startsWith('audio/') ||
     contentType.startsWith('video/') ||
     contentType.startsWith('application/pdf') ||
     contentType.startsWith('application/x-pdf') ||
     supportedFileExtensions.includes(fileExtension)
   );
 });
}

async function processPromptAndMediaAttachments(prompt, message, botMessage) {
 const attachments = JSON.parse(JSON.stringify(Array.from(message.attachments.values())));
 let parts = [{
   text: prompt
 }];
 
 if (attachments.length > 0) {
   const validMediaAttachments = attachments.filter(attachment => {
     const contentType = (attachment.contentType || "").toLowerCase();
     // Include image/, audio/, video/ (GIFs are handled as images by the API) and PDF
     return contentType.startsWith('image/') ||
       contentType.startsWith('audio/') ||
       contentType.startsWith('video/') ||
       contentType.startsWith('application/pdf') ||
       contentType.startsWith('application/x-pdf');
   });

   if (validMediaAttachments.length > 0) {
     const attachmentParts = await Promise.all(
       validMediaAttachments.map(async (attachment) => {
         const sanitizedFileName = sanitizeFileName(attachment.name);
         const uniqueTempFilename = `${message.author.id}-${attachment.id}-${sanitizedFileName}`;
         const filePath = path.join(TEMP_DIR, uniqueTempFilename);
         const contentType = attachment.contentType || '';

         try {
           await downloadFile(attachment.url, filePath);
           
           // --- File Upload with Retry and Processing Check (Crucial for Videos) ---
           let uploadResult;
           let file;
           
           await retryOperation(async () => {
               uploadResult = await genAI.files.upload({
                   file: filePath,
                   config: {
                       mimeType: contentType,
                       displayName: sanitizedFileName,
                   }
               });
               
               const name = uploadResult.name;
               if (!name) {
                   throw new Error(`Unable to extract file name from upload result.`);
               }
               
               if (contentType.startsWith('video/')) {
                   // Wait for video processing to complete
                   file = await genAI.files.get({ name: name });
                   while (file.state === 'PROCESSING') {
                       // Send feedback to user about video processing
                       if (botMessage) {
                            const thinkingEmbed = EmbedBuilder.from(botMessage.embeds[0] || new EmbedBuilder().setColor(0x00FFFF).setTitle('Processing Request'));
                            thinkingEmbed.setDescription(thinkingEmbed.description.replace('Media Attachment Check', 'Media Attachment Check (Video Processing...)'));
                            await botMessage.edit({ embeds: [thinkingEmbed] }).catch(console.error);
                       }
                       process.stdout.write(".");
                       await delay(10_000);
                       file = await genAI.files.get({ name: name });
                   }
                   if (file.state === 'FAILED') {
                       throw new Error(`Video processing failed for ${sanitizedFileName}.`);
                   }
               }
           }, 3, 5000); // 3 retries, 5s delay

           return createPartFromUri(uploadResult.uri, uploadResult.mimeType);
         } catch (error) {
           console.error(`Error processing attachment ${sanitizedFileName}:`, error);
           // Inform user about the specific failure for that file
           message.channel.send({
               embeds: [new EmbedBuilder().setColor(0xFF8800).setDescription(`⚠️ Failed to process file: \`${sanitizedFileName}\`. It will be skipped for the current response.`)],
               content: `<@${message.author.id}>`
           }).catch(console.error);
           return null;
         } finally {
           try {
             await fs.unlink(filePath);
           } catch (unlinkError) {
             if (unlinkError.code !== 'ENOENT') {
               console.error(`Error deleting temporary file ${filePath}:`, unlinkError);
             }
           }
         }
       })
     );
     parts = [...parts, ...attachmentParts.filter(part => part !== null)];
   }
 }
 return parts;
}

// downloadFile and sanitizeFileName are kept unchanged
async function downloadFile(url, filePath) {
 const writer = createWriteStream(filePath);
 const response = await axios({
   url,
   method: 'GET',
   responseType: 'stream',
 });
 response.data.pipe(writer);
 return new Promise((resolve, reject) => {
   writer.on('finish', resolve);
   writer.on('error', reject);
 });
}

function sanitizeFileName(fileName) {
 return fileName
   .toLowerCase()
   .replace(/[^a-z0-9-]/g, '-')
   .replace(/^-+|-+$/g, '');
}


// extractFileText and downloadAndReadFile are kept unchanged
async function extractFileText(message, messageContent) {
 if (message.attachments.size > 0) {
   let attachments = Array.from(message.attachments.values());
   for (const attachment of attachments) {
     const fileType = path.extname(attachment.name) || '';
     const fileTypes = ['.html', '.js', '.css', '.json', '.xml', '.csv', '.py', '.java', '.sql', '.log', '.md', '.txt', '.docx', '.pptx'];

     if (fileTypes.includes(fileType)) {
       try {
         let fileContent = await downloadAndReadFile(attachment.url, fileType);
         messageContent += `\n\n[\`${attachment.name}\` File Content]:\n\`\`\`\n${fileContent}\n\`\`\``;
       } catch (error) {
         console.error(`Error reading file ${attachment.name}: ${error.message}`);
       }
     }
   }
 }
 return messageContent;
}

async function downloadAndReadFile(url, fileType) {
 switch (fileType) {
   case 'pptx':
   case 'docx':
     const extractor = getTextExtractor();
     return (await extractor.extractText({
       input: url,
       type: 'url'
     }));
   default:
     const response = await fetch(url);
     if (!response.ok) throw new Error(`Failed to download ${response.statusText}`);
     return await response.text();
 }
}

// <==========>


// <=====[Interaction Reply Helpers (Updated)]=====>

// Updated to use the new actionButtons preference
async function addDownloadAndSaveButtons(botMessage, actionButtons, msgId) {
 if (!actionButtons) {
     return botMessage.edit({ components: [] }).catch(console.error);
 }
 
 try {
   const components = botMessage.components || [];
   let actionRow = components.find(row => row.type === ComponentType.ActionRow) || new ActionRowBuilder();

   // Remove existing action buttons to prevent duplicates on edits
   const existingIds = actionRow.components.map(c => c.customId);
   actionRow.components = actionRow.components.filter(c => !c.customId.includes('settings') && !c.customId.includes('download_message') && !c.customId.includes('delete_message'));

   const stopButton = new ButtonBuilder()
     .setCustomId('stopGenerating')
     .setLabel('Stop')
     .setEmoji('🛑')
     .setStyle(ButtonStyle.Danger);
     
   const downloadButton = new ButtonBuilder()
     .setCustomId('download_message')
     .setLabel('Save')
     .setEmoji('⬇️')
     .setStyle(ButtonStyle.Secondary);

   const deleteButton = new ButtonBuilder()
     .setCustomId(`delete_message-${msgId}`)
     .setLabel('Delete')
     .setEmoji('🗑️')
     .setStyle(ButtonStyle.Secondary);

   actionRow.addComponents(stopButton, downloadButton, deleteButton);
   
   // Ensure the settings button is at the end if it was already present
   const settingsButton = components.find(c => c.customId === 'settings');
   if (settingsButton && !actionRow.components.some(c => c.customId === 'settings')) {
       actionRow.addComponents(settingsButton);
   }
   
   return await botMessage.edit({ components: [actionRow] });
 } catch (error) {
   console.error('Error adding action buttons:', error.message);
   return botMessage;
 }
}

async function addSettingsButton(botMessage, responseColor, actionButtons) {
 if (!actionButtons) {
     return botMessage; // Do not show settings button if action buttons are hidden
 }
 try {
   const settingsButton = new ButtonBuilder()
     .setCustomId('settings')
     .setEmoji('⚙️')
     .setStyle(ButtonStyle.Secondary);

   const components = botMessage.components || [];
   let actionRow = components.find(row => row.type === ComponentType.ActionRow) || new ActionRowBuilder();

   // Prevent adding duplicates and ensure settings is present
   if (!actionRow.components.some(c => c.customId === 'settings')) {
       actionRow.addComponents(settingsButton);
   }
   
   return await botMessage.edit({ components: [actionRow] });
 } catch (error) {
   console.log('Error adding settings button:', error.message);
   return botMessage;
 }
}

async function handleDeleteMessageInteraction(interaction, msgId) {
 const userId = interaction.user.id;
 const userChatHistory = state.chatHistories[userId];
 const channel = interaction.channel;
 
 // The original message the bot replied to
 const originalMessage = await channel.messages.fetch(msgId).catch(() => null);

 // Check if the user is the original author OR the message is not found (which means the user owns the history ID)
 // For interaction message deletes, only the original author or an admin should be able to delete the bot's *reply*.
 const isOriginalAuthor = interaction.user.id === originalMessage?.reference?.messageId; // This is incorrect, need to check if bot replied to user
 const isReplyToUser = originalMessage?.reference?.messageId;
 const originalUser = isReplyToUser ? (await channel.messages.fetch(originalMessage.reference.messageId).catch(() => null))?.author.id : null;
 const isAuthor = originalUser === userId;
 
 if (isAuthor || interaction.memberPermissions.has(PermissionFlagsBits.ManageMessages)) {
     await deleteMsg();
 } else {
     const embed = new EmbedBuilder()
         .setColor(0xFF0000)
         .setTitle('Not For You')
         .setDescription('This button is not meant for you.');
     return interaction.reply({
         embeds: [embed],
         flags: MessageFlags.Ephemeral
     });
 }

 async function deleteMsg() {
   // Delete the bot's response message
   await interaction.message.delete().catch('Error deleting interaction message: ', console.error);
   
   // Optional: Delete the original message if it exists and the user is the author
   if (originalMessage && originalMessage.reference?.messageId) {
       // Fetch the message the bot replied to and delete it only if the user is the original author
       const userMsg = await channel.messages.fetch(originalMessage.reference.messageId).catch(() => null);
       if (userMsg && userMsg.author.id === userId) {
           await userMsg.delete().catch(console.error);
       }
   }
 }
}

// <==========>


// <=====[Model Response Handling]=====>

async function handleModelResponse(botMessage, chat, parts, originalMessage, typingInterval, historyId, continuousReply, responseColor, responseStyle, actionButtons) {
 const userId = originalMessage.author.id;
 const maxCharacterLimit = responseStyle === 'Embedded' ? 3900 : 1900; // Custom max char limit
 const isContinuous = continuousReply;
 let attempts = 3;

 let updateTimeout;
 let tempResponse = '';
 let groundingMetadata = null;
 let urlContextMetadata = null;

 // Initial update to show the stop button
 if (botMessage) {
     await addDownloadAndSaveButtons(botMessage, actionButtons, originalMessage.id);
 }

 let stopGeneration = false;
 const filter = (interaction) => interaction.customId === 'stopGenerating';
 try {
   const collector = await botMessage.createMessageComponentCollector({
     filter,
     time: 120000
   });
   collector.on('collect', (interaction) => {
     // Allow stop if the user is the message author or has Manage Messages permission
     if (interaction.user.id === originalMessage.author.id || interaction.memberPermissions?.has(PermissionFlagsBits.ManageMessages)) {
       try {
         const embed = new EmbedBuilder()
           .setColor(0xFFA500)
           .setTitle('Response Stopped')
           .setDescription('Response generation stopped by the user.');

         interaction.reply({
           embeds: [embed],
           flags: MessageFlags.Ephemeral
         });
       } catch (error) {
         console.error('Error sending reply:', error);
       }
       stopGeneration = true;
     } else {
       try {
         const embed = new EmbedBuilder()
           .setColor(0xFF0000)
           .setTitle('Access Denied')
           .setDescription("It's not for you.");

         interaction.reply({
           embeds: [embed],
           flags: MessageFlags.Ephemeral
         });
       } catch (error) {
         console.error('Error sending unauthorized reply:', error);
       }
     }
   });
 } catch (error) {
   console.error('Error creating or handling collector:', error);
 }

 const updateMessage = () => {
   if (stopGeneration) {
     return;
   }
   if (tempResponse.trim() === "") {
     botMessage.edit({
       content: '...'
     });
   } else if (responseStyle === 'Embedded') {
     updateEmbed(botMessage, tempResponse, originalMessage, groundingMetadata, urlContextMetadata, responseColor);
   } else {
     botMessage.edit({
       content: tempResponse,
       embeds: []
     });
   }
   clearTimeout(updateTimeout);
   updateTimeout = null;
 };
 
 clearInterval(typingInterval); // Stop the initial typing interval before generation starts

 while (attempts > 0 && !stopGeneration) {
   try {
     let finalResponse = '';
     let isLargeResponse = false;
     const newHistory = [];
     
     // Store user prompt in newHistory for persistence
     newHistory.push({
       role: 'user',
       content: parts
     });
     
     let finalModelResponseParts = [];

     async function getResponse(parts) {
       const messageResult = await chat.sendMessageStream({
         message: parts
       });
       
       for await (const chunk of messageResult) {
         if (stopGeneration) break;

         const chunkText = (chunk.text || (chunk.codeExecutionResult?.output ? `\n\`\`\`output\n${chunk.codeExecutionResult.output}\n\`\`\`\n` : "") || (chunk.executableCode ? `\n\`\`\`\n${chunk.executableCode}\n\`\`\`\n` : ""));
         
         if (chunkText && chunkText !== '') {
           finalResponse += chunkText;
           tempResponse += chunkText;
           
           // For persistence, only store the final response text parts
           finalModelResponseParts.push({ text: chunkText });
         }

         if (chunk.candidates && chunk.candidates[0]?.groundingMetadata) {
           groundingMetadata = chunk.candidates[0].groundingMetadata;
         }

         if (chunk.candidates && chunk.candidates[0]?.url_context_metadata) {
           urlContextMetadata = chunk.candidates[0].url_context_metadata;
         }

         if (finalResponse.length > maxCharacterLimit) {
           if (!isLargeResponse) {
             isLargeResponse = true;
             
             // Clear previous embed/content and send a warning
             botMessage.edit({
               content: `Response is too large! Preparing to send as a file...`,
               embeds: []
             }).catch(console.error);
           }
         } else if (!updateTimeout) {
           updateTimeout = setTimeout(updateMessage, 500);
         }
       }
       
       // Final response part for history
       newHistory.push({
         role: 'assistant',
         content: finalModelResponseParts
       });
     }
     
     await getResponse(parts);

     // Final message update cleanup
     if (updateTimeout) {
         clearTimeout(updateTimeout);
     }
     
     // Remove stop button regardless of success/failure
     const finalComponents = botMessage.components.map(row => {
         const newRow = ActionRowBuilder.from(row);
         newRow.components = newRow.components.filter(c => c.customId !== 'stopGenerating');
         return newRow;
     }).filter(row => row.components.length > 0);

     if (finalResponse.trim() === '') {
         finalResponse = 'I apologize, but I was unable to generate a response. Please try again or rephrase your query.';
         responseStyle = 'Embedded'; // Force embed for error
     }

     if (isLargeResponse) {
       // Send as a file for large responses
       await sendAsTextFile(finalResponse, originalMessage, botMessage.id, actionButtons);
       // Delete the initial botMessage
       await botMessage.delete().catch(console.error);
       
     } else {
       // Update the final message with the full content/embed
       if (responseStyle === 'Embedded') {
         await updateEmbed(botMessage, finalResponse, originalMessage, groundingMetadata, urlContextMetadata, responseColor);
       } else {
         await botMessage.edit({ content: finalResponse, embeds: [] }).catch(console.error);
       }
       
       // Add final action buttons and settings button
       await addSettingsButton(botMessage, responseColor, actionButtons);
       await addDownloadAndSaveButtons(botMessage, actionButtons, botMessage.id);
     }

     // Save history only on successful generation
     await chatHistoryLock.runExclusive(async () => {
       updateChatHistory(historyId, newHistory, isLargeResponse ? originalMessage.id : botMessage.id);
       await saveStateToFile();
     });
     break;
   } catch (error) {
     if (activeRequests.has(userId)) {
       activeRequests.delete(userId);
     }
     console.error('Generation Attempt Failed: ', error);
     attempts--;

     if (attempts === 0 || stopGeneration) {
       if (!stopGeneration) {
         const errorTitle = attempts === 0 ? 'Generation Failure' : 'Bot Overloaded';
         const errorDescription = attempts === 0 ? `All Generation Attempts Failed :(\n\`\`\`${error.message}\`\`\`` : 'Something seems off, the bot might be overloaded! :(';
         const errorEmbed = new EmbedBuilder()
             .setColor(0xFF0000)
             .setTitle(errorTitle)
             .setDescription(SEND_RETRY_ERRORS_TO_DISCORD ? errorDescription : 'An internal error prevented me from completing your request. Please try again.');
           
         await botMessage.edit({
           content: `<@${originalMessage.author.id}>`,
           embeds: [errorEmbed],
           components: []
         }).catch(console.error);
         await addSettingsButton(botMessage, responseColor, actionButtons);
       }
       break;
     } else if (SEND_RETRY_ERRORS_TO_DISCORD) {
       const errorMsg = await originalMessage.channel.send({
         content: `<@${originalMessage.author.id}>`,
         embeds: [new EmbedBuilder()
           .setColor(0xFFFF00)
           .setTitle('Retry in Progress')
           .setDescription(`Generation Attempt(s) Failed, Retrying..\n\`\`\`${error.message}\`\`\``)
         ]
       });
       setTimeout(() => errorMsg.delete().catch(console.error), 5000);
       await delay(500);
     }
   }
 }
 if (activeRequests.has(userId)) {
   activeRequests.delete(userId);
 }
}

function updateEmbed(botMessage, finalResponse, message, groundingMetadata = null, urlContextMetadata = null, color) {
 try {
   const isGuild = message.guild !== null;
   const embed = new EmbedBuilder()
     .setColor(color)
     .setDescription(finalResponse)
     .setAuthor({
       name: `Response to ${message.author.displayName}`,
       iconURL: message.author.displayAvatarURL()
     })
     .setTimestamp();

   if (groundingMetadata) {
     addGroundingMetadataToEmbed(embed, groundingMetadata);
   }

   if (urlContextMetadata) {
     addUrlContextMetadataToEmbed(embed, urlContextMetadata);
   }

   if (isGuild) {
     embed.setFooter({
       text: message.guild.name,
       iconURL: message.guild.iconURL() || 'https://ai.google.dev/static/site-assets/images/share.png'
     });
   }

   botMessage.edit({
     content: ' ',
     embeds: [embed]
   }).catch(console.error);
 } catch (error) {
   console.error("An error occurred while updating the embed:", error.message);
 }
}

function addGroundingMetadataToEmbed(embed, groundingMetadata) {
 // Add search queries used by the model
 if (groundingMetadata.webSearchQueries && groundingMetadata.webSearchQueries.length > 0) {
   // Only add if the field doesn't exist to prevent duplicates on stream updates
   if (!embed.data.fields || !embed.data.fields.some(f => f.name.includes('Search Queries'))) {
     embed.addFields({
       name: '🔍 Search Queries',
       value: groundingMetadata.webSearchQueries.map(query => `• ${query}`).join('\n'),
       inline: false
     });
   }
 }

 // Add grounding sources with clickable links
 if (groundingMetadata.groundingAttributions && groundingMetadata.groundingAttributions.length > 0) {
   // Check if the field exists
   const existingSourcesField = embed.data.fields?.find(f => f.name.includes('Sources'));
   if (!existingSourcesField) {
       const chunks = groundingMetadata.groundingAttributions
         .slice(0, 5) // Limit to first 5 chunks to avoid embed limits
         .map((attribution, index) => {
           if (attribution.web) {
             return `• [${attribution.web.title || 'Source'}](${attribution.web.uri})`;
           }
           return `• Source ${index + 1}`;
         })
         .join('\n');
       
       embed.addFields({
         name: '📚 Sources',
         value: chunks,
         inline: false
       });
   }
 }
}

function addUrlContextMetadataToEmbed(embed, urlContextMetadata) {
 if (urlContextMetadata.url_metadata && urlContextMetadata.url_metadata.length > 0) {
     const existingUrlField = embed.data.fields?.find(f => f.name.includes('URL Context'));
     if (!existingUrlField) {
       const urlList = urlContextMetadata.url_metadata
         .map(urlData => {
           const emoji = urlData.url_retrieval_status === 'URL_RETRIEVAL_STATUS_SUCCESS' ? '✔️' : '❌';
           return `${emoji} [${urlData.retrieved_url}](${urlData.retrieved_url})`;
         })
         .join('\n');
       
       embed.addFields({
         name: '🔗 URL Context',
         value: urlList,
         inline: false
       });
     }
 }
}


async function sendAsTextFile(text, message, orgId, actionButtons) {
 try {
   const filename = `response-${Date.now()}.txt`;
   const tempFilePath = path.join(TEMP_DIR, filename);
   await fs.writeFile(tempFilePath, text);

   // Use send instead of reply to prevent mention if continuous reply is ON
   const botMessage = await message.channel.send({
     content: `<@${message.author.id}>, The response was too long and has been converted to a file:`,
     files: [tempFilePath]
   });

   // Add settings and delete button to the file message
   await addSettingsButton(botMessage, getColor(message.guild?.id, message.author.id), actionButtons);
   await addDownloadAndSaveButtons(botMessage, actionButtons, orgId);

   await fs.unlink(tempFilePath);
 } catch (error) {
   console.error('An error occurred while sending large file:', error);
 }
}


client.login(token);