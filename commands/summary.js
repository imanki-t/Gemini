import { EmbedBuilder, MessageFlags } from 'discord.js';
import { genAI, TEMP_DIR } from '../botManager.js';
import { fetchMessagesForSummary } from '../modules/utils.js';
import path from 'path';
import fs from 'fs/promises';

const SUMMARY_MODEL = 'gemini-2.5-flash';

export const summaryCommand = {
  name: 'summary',
  description: 'Summarize a conversation based on a message link'
};

export async function handleSummaryCommand(interaction) {
  try {
    const link = interaction.options.getString('link');
    const count = interaction.options.getInteger('count') || 50;

    await interaction.deferReply();

    // The fetchMessagesForSummary utility handles permission checks and finding the message
    // Pass interaction as the "message" context for checks (it has .channel, .guild, etc.)
    // Note: utils.js expects a Message-like object or at least { guild, channel, author } for some logic
    // We'll mock a simple message-like object or rely on interaction having compatible props
    
    // Actually, fetchMessagesForSummary uses client.guilds.cache.get(guildId) from the link
    // It takes `message` just to check perms of the bot, or uses client.
    // Let's pass the interaction, but we need to ensure the logic in utils.js works with it.
    // utils.js calls: client.guilds.cache.get, channel.messages.fetch, etc.
    // It returns an object with { success, content, messageCount, channelName, guildName }
    
    // We need to pass the "message" argument. In utils.js it's used for:
    // This argument is actually unused in the current version of utils.js provided in the prompt context!
    // It extracts guildId/channelId from the LINK.
    // Wait, let's verify utils.js content from the prompt...
    // The provided file content shows: `export async function fetchMessagesForSummary(message, messageLink, count = 1) { ... }`
    // Inside it uses `client.guilds.cache.get(guildId)`... it does NOT use the `message` argument except maybe for logging?
    // Actually, it doesn't use the `message` argument at all in the provided snippet.
    // So passing interaction should be fine or null.
    
    // However, for safety, let's pass a dummy object if needed, but interaction works.
    
    const result = await fetchMessagesForSummary(interaction, link, count);

    if (result.error) {
      const errorEmbed = new EmbedBuilder()
        .setColor(0xFF5555)
        .setTitle('âŒ Summary Failed')
        .setDescription(result.error);
      return interaction.editReply({ embeds: [errorEmbed] });
    }

    if (!result.success || !result.content) {
      return interaction.editReply({ content: 'Failed to fetch messages for summary.' });
    }

    // Prepare content for AI
    const fileName = `summary_${interaction.id}_${Date.now()}.txt`;
    const filePath = path.join(TEMP_DIR, fileName);
    const fileContent = `Discord Messages Summary Context\nChannel: #${result.channelName}\nServer: ${result.guildName}\nMessages Fetched: ${result.messageCount}\n\n${result.content}`;

    await fs.writeFile(filePath, fileContent);

    // Upload to Gemini
    const uploadResult = await genAI.files.upload({
      file: filePath,
      config: {
        mimeType: 'text/plain',
        displayName: 'Discord Conversation Log'
      }
    });

    await fs.unlink(filePath).catch(() => {});

    // Generate Summary
    const model = genAI.models; 
    // We use the simpler generateContent interface via our wrapper
    
    const prompt = `Please analyze the attached conversation log from Discord.
    
    Provide a clear, structured summary of the discussion.
    - Highlight key topics discussed.
    - Identify active participants.
    - Mention any decisions made or funny moments.
    - Keep the tone helpful and concise.
    
    The log contains approximately ${result.messageCount} messages centered around the provided link.`;

    const request = {
      model: SUMMARY_MODEL,
      contents: [{
        role: 'user',
        parts: [
          { text: prompt },
          {
            fileData: {
              fileUri: uploadResult.uri,
              mimeType: uploadResult.mimeType
            }
          }
        ]
      }]
    };

    const genResult = await genAI.models.generateContent(request);
    const summaryText = genResult.text || "Could not generate summary.";

    const embed = new EmbedBuilder()
      .setColor(0x00FF00)
      .setTitle(`ðŸ“ Conversation Summary`)
      .setDescription(summaryText.slice(0, 4096))
      .addFields(
        { name: 'ðŸ“ Context', value: `[Jump to Start Message](${link})`, inline: true },
        { name: 'ðŸ“Š Messages Analyzed', value: `${result.messageCount}`, inline: true },
        { name: 'ðŸ“‚ Channel', value: `#${result.channelName}`, inline: true }
      )
      .setFooter({ text: `Generated by ${interaction.user.displayName}` })
      .setTimestamp();

    await interaction.editReply({ embeds: [embed] });

  } catch (error) {
    console.error('Error in handleSummaryCommand:', error);
    await interaction.editReply({ 
      content: 'An error occurred while generating the summary.' 
    }).catch(() => {});
  }
}
