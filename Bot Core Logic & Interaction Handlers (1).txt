// index.js

import {
 MessageFlags,
 ActionRowBuilder,
 ButtonBuilder,
 ButtonStyle,
 ChannelType,
 TextInputBuilder,
 TextInputStyle,
 ModalBuilder,
 PermissionsBitField,
 EmbedBuilder,
 AttachmentBuilder,
 ActivityType,
 ComponentType,
 REST,
 Routes,
 StringSelectMenuBuilder,
 StringSelectMenuOptionBuilder,
} from 'discord.js';
import {
 HarmBlockThreshold,
 HarmCategory
} from '@google/genai';
import fs from 'fs/promises';
import {
 createWriteStream
} from 'fs';
import path from 'path';
import {
 getTextExtractor
} from 'office-text-extractor'
import osu from 'node-os-utils';
const {
 mem,
 cpu
} = osu;
import axios from 'axios';
import url from 'url';
import util from 'util';

import config from './config.js';
import {
 client,
 genAI,
 createPartFromUri,
 token,
 activeRequests,
 chatHistoryLock,
 state,
 TEMP_DIR,
 initialize,
 saveStateToFile,
 getHistory,
 updateChatHistory,
 getEffectiveUserConfig, 
 initializeBlacklistForGuild,
 initializeUserSettings,
} from './botManager.js';

initialize().catch(console.error);


// <=====[Configuration]=====>

// Safety settings are static as they are applied universally
const safetySettings = [{
   category: HarmCategory.HARM_CATEGORY_HARASSMENT,
   threshold: HarmBlockThreshold.BLOCK_NONE,
 },
 {
   category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
   threshold: HarmBlockThreshold.BLOCK_NONE,
 },
 {
   category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
   threshold: HarmBlockThreshold.BLOCK_NONE,
 },
 {
   category: HarmCategory.HARM_CATEGORY.HARM_CATEGORY_DANGEROUS_CONTENT,
   threshold: HarmBlockThreshold.BLOCK_NONE,
 },
];

const generationConfig = {
 temperature: 1.0,
 topP: 0.95,
 thinkingConfig: {
   thinkingBudget: -1
 }
};

const activities = config.activities.map(activity => ({
 name: activity.name,
 type: ActivityType[activity.type]
}));
const defaultPersonality = config.defaultPersonality;
const SEND_RETRY_ERRORS_TO_DISCORD = config.SEND_RETRY_ERRORS_TO_DISCORD;
const AVAILABLE_MODELS = config.AVAILABLE_MODELS; 

import {
 delay,
 retryOperation,
} from './tools/others.js';

// <==========>


// <=====[Register Commands And Activities]=====>

import {
 commands
} from './commands.js';

let activityIndex = 0;
client.once('ready', async () => {
 console.log(`Logged in as ${client.user.tag}!`);

 const rest = new REST().setToken(token);
 try {
   console.log('Started refreshing application (/) commands.');

   await rest.put(
     Routes.applicationCommands(client.user.id), {
       body: commands
     },
   );

   console.log('Successfully reloaded application (/) commands.');
 } catch (error) {
   console.error(error);
 }

 client.user.setPresence({
   activities: [activities[activityIndex]],
   status: 'idle',
 });

 setInterval(() => {
   activityIndex = (activityIndex + 1) % activities.length;
   client.user.setPresence({
     activities: [activities[activityIndex]],
     status: 'idle',
   });
 }, 30000);
});

// <==========>


// <=====[Messages And Interaction]=====>

client.on('messageCreate', async (message) => {
 try {
   if (message.author.bot) return;
   if (message.content.startsWith('!')) return;

   const isDM = message.channel.type === ChannelType.DM;
   const { continuousReply } = getEffectiveUserConfig(message.author.id, message.guild?.id);

   // Determines if the bot should respond (mention, continuous reply in channel, or DM)
   const shouldRespond = (
     config.workInDMs && isDM ||
     state.alwaysRespondChannels[message.channelId] ||
     (message.mentions.users.has(client.user.id) && !isDM) ||
     (continuousReply && !message.mentions.users.has(client.user.id) && state.activeUsersInChannels[message.channelId]?.[message.author.id])
   );

   if (shouldRespond) {
     if (message.guild) {
       initializeBlacklistForGuild(message.guild.id);
       if (state.blacklistedUsers[message.guild.id].includes(message.author.id)) {
         const embed = new EmbedBuilder()
           .setColor(0xFF0000)
           .setTitle('Blacklisted')
           .setDescription('You are blacklisted and cannot use this bot.');
         return message.reply({
           embeds: [embed]
         });
       }
     }

     initializeUserSettings(message.author.id); 

     if (activeRequests.has(message.author.id)) {
       const embed = new EmbedBuilder()
         .setColor(0xFFFF00)
         .setTitle('Request In Progress')
         .setDescription('Please wait until your previous action is complete.');
       await message.reply({
         embeds: [embed]
       });
     } else {
       activeRequests.add(message.author.id);
       await handleTextMessage(message);
     }
   }
 } catch (error) {
   console.error('Error processing the message:', error);
   if (activeRequests.has(message.author.id)) {
     activeRequests.delete(message.author.id);
   }
 }
});

client.on('interactionCreate', async (interaction) => {
 try {
   if (interaction.isChatInputCommand()) {
     await handleCommandInteraction(interaction);
   } else if (interaction.isButton() || interaction.isStringSelectMenu()) {
     await handleComponentInteraction(interaction);
   } else if (interaction.isModalSubmit()) {
     await handleModalSubmit(interaction);
   }
 } catch (error) {
   console.error('Error handling interaction:', error.message);
   if (interaction.deferred || interaction.replied) {
     await interaction.editReply({
       content: `❌ An unexpected error occurred: \`${error.message}\``,
       embeds: [],
       components: [],
     }).catch(e => console.error("Could not send final error reply:", e.message));
   } else {
     await interaction.reply({
       content: `❌ An unexpected error occurred: \`${error.message}\``,
       flags: MessageFlags.Ephemeral
     });
   }
 }
});

async function handleCommandInteraction(interaction) {
 if (!interaction.isChatInputCommand()) return;

 const commandHandlers = {
   settings: showSettings,
   search: handleSearchCommand,
   // imagine: handleImagineCommand,
 };

 const handler = commandHandlers[interaction.commandName];
 if (handler) {
   await handler(interaction);
 } else {
   console.log(`Unknown command: ${interaction.commandName}`);
   await interaction.reply({
     content: `Unknown command: \`${interaction.commandName}\``,
     flags: MessageFlags.Ephemeral
   });
 }
}

async function handleComponentInteraction(interaction) {
 if (interaction.guild) {
   initializeBlacklistForGuild(interaction.guild.id);
   if (state.blacklistedUsers[interaction.guild.id].includes(interaction.user.id)) {
     const embed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('Blacklisted')
       .setDescription('You are blacklisted and cannot use this interaction.');
     return interaction.reply({
       embeds: [embed],
       flags: MessageFlags.Ephemeral
     });
   }
 }
 initializeUserSettings(interaction.user.id); 

 const customId = interaction.customId;

 const isServerSetting = customId.includes('server-');
 const canManageServer = interaction.guild && interaction.member.permissions.has(PermissionsBitField.Flags.ManageGuild);

 if (isServerSetting && !canManageServer) {
   const embed = new EmbedBuilder()
     .setColor(0xFF0000)
     .setTitle('Permission Denied')
     .setDescription('You need the **Manage Server** permission to modify server settings.');
   return interaction.reply({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
 }

 const componentHandlers = {
   // Top-level navigation
   'user-settings': showUserSettingsEmbed,
   'server-settings': showServerSettingsEmbed,
   'back-to-main-settings': showSettings,

   // User/Server Settings
   'model-select': handleModelSelect,
   'user-continuous-reply': toggleContinuousReply,
   'server-continuous-reply': toggleContinuousReply,
   'user-response-style': handleResponseStyle,
   'server-response-style': handleResponseStyle,
   'user-action-buttons': toggleActionButtons,
   'server-action-buttons': toggleActionButtons,
   'server-override-user': toggleOverrideUser,

   // History & Personality Management
   'clear-user-history': clearChatHistory,
   'download-user-history': downloadConversation,
   'user-custom-personality': setCustomPersonality,
   'user-remove-personality': removeCustomPersonality,
   'clear-server-history': clearServerChatHistory,
   'download-server-history': downloadServerConversation,
   'server-custom-personality': serverPersonality,
   'server-remove-personality': removeServerPersonality,
   
   // Response/Message interactions
   'stopGenerating': stopGenerationInteraction,
   'download-message': downloadMessage,
 };

 for (const [key, handler] of Object.entries(componentHandlers)) {
   if (customId.startsWith(key)) {
     await handler(interaction);
     return;
   }
 }

 if (customId.startsWith('delete_message-')) {
   const msgId = customId.replace('delete_message-', '');
   await handleDeleteMessageInteraction(interaction, msgId);
 }
}

async function stopGenerationInteraction(interaction) {
 const botMessageId = interaction.message.id;
 const requestInfo = activeRequests.get(interaction.user.id);

 if (requestInfo && requestInfo.botMessageId === botMessageId) {
   requestInfo.stopGeneration = true;
   activeRequests.delete(interaction.user.id);

   const components = interaction.message.components.map(row => {
     if (row.components.some(c => c.customId === 'stopGenerating')) {
       const newRow = ActionRowBuilder.from(row);
       newRow.components.forEach(c => {
         if (c.customId === 'stopGenerating') c.setDisabled(true).setLabel('Stopped').setStyle(ButtonStyle.Danger);
       });
       return newRow;
     }
     return row;
   });

   await interaction.update({ components });

   const embed = new EmbedBuilder()
     .setColor(0xFFA500)
     .setTitle('Response Stopped')
     .setDescription('Response generation stopped by the user.');

   await interaction.followUp({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
 } else {
   const embed = new EmbedBuilder()
     .setColor(0xFF0000)
     .setTitle('Access Denied')
     .setDescription("This button is either not for you or the response has already finished.");
   await interaction.reply({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
 }
}

// <==========>


// <=====[New Command Handlers]=====>

async function showSettings(interaction) {
 const isUpdate = interaction.replied || interaction.deferred;
 const isGuild = interaction.guild !== null;
 const canManageServer = interaction.guild ? interaction.member.permissions.has(PermissionsBitField.Flags.ManageGuild) : false;

 const userButton = new ButtonBuilder()
   .setCustomId('user-settings')
   .setLabel('My User Settings')
   .setEmoji('👤')
   .setStyle(ButtonStyle.Primary);

 const serverButton = new ButtonBuilder()
   .setCustomId('server-settings')
   .setLabel('Server Settings')
   .setEmoji('🏢')
   .setStyle(ButtonStyle.Secondary)
   .setDisabled(!isGuild || !canManageServer); 

 const actionRow = new ActionRowBuilder().addComponents(userButton);
 if (isGuild) {
   actionRow.addComponents(serverButton);
 }

 const embed = new EmbedBuilder()
   .setColor(config.hexColour)
   .setTitle('⚙️ Bot Configuration Dashboard')
   .setDescription(
     `Welcome to the bot's central configuration panel. Choose a category below to manage settings.

     **User Settings** (👤): Personal preferences that apply to your interactions globally (unless overridden by server settings).
     ${isGuild ? `**Server Settings** (🏢): Global settings for this server (Requires **Manage Server** permission).` : ''}`
   )
   .setFooter({ text: client.user.username, iconURL: client.user.displayAvatarURL() })
   .setTimestamp();

 if (isUpdate) {
   await interaction.update({
     embeds: [embed],
     components: [actionRow],
     flags: MessageFlags.Ephemeral
   });
 } else {
   await interaction.reply({
     embeds: [embed],
     components: [actionRow],
     flags: MessageFlags.Ephemeral
   });
 }
}

async function handleSearchCommand(interaction) {
 await interaction.deferReply();

 const userId = interaction.user.id;
 const guildId = interaction.guild?.id;
 let messageContent = interaction.options.getString('prompt') || '';
 let parts;

 const originalMessage = await interaction.channel.messages.fetch(interaction.id).catch(e => {
   console.error("Could not fetch message for attachments:", e);
   return null;
 });

 if (!originalMessage) {
   return interaction.editReply({ content: '❌ Could not retrieve message data. Please ensure you attached a file alongside the `/search` command if you intended to.', embeds: [], components: [] });
 }

 const updateEmbedDescription = (textStatus, mediaStatus, finalized = false) => {
   const textEmoji = textStatus === '✅' ? '✅' : '🔄';
   const mediaEmoji = mediaStatus === '✅' ? '✅' : '🔄';
   return `Let me think...\n\n- ${textEmoji} **Text Attachment Check**\n- ${mediaEmoji} **Media Attachment Check**${finalized ? '\n\n**All checks done. Waiting for the response...**' : ''}`;
 };

 const processingEmbed = new EmbedBuilder()
   .setColor(0x00FFFF)
   .setTitle('🔎 Processing Multimodal Query')
   .setDescription(updateEmbedDescription('🔄', '🔄'));

 await interaction.editReply({ embeds: [processingEmbed] });


 try {
   messageContent = await extractFileText(originalMessage, messageContent);
   processingEmbed.setDescription(updateEmbedDescription('✅', '🔄'));
   await interaction.editReply({ embeds: [processingEmbed] });

   parts = await processPromptAndMediaAttachments(messageContent, originalMessage);
   processingEmbed.setDescription(updateEmbedDescription('✅', '✅', true));
   await interaction.editReply({ embeds: [processingEmbed] });

 } catch (error) {
   console.error('Error during search preprocessing:', error);
   return interaction.editReply({
     content: `❌ **Failed to process attachments or text.** Error: \`${error.message}\``,
     embeds: [],
     components: []
   });
 }

 const { effectiveConfig, overrideMessage } = getEffectiveUserConfig(userId, guildId);

 let instructions = effectiveConfig.customPersonality ? state.customInstructions[userId] : defaultPersonality;
 if (guildId) {
   if (state.channelWideChatHistory[originalMessage.channelId]) {
     instructions = state.customInstructions[originalMessage.channelId];
   } else if (effectiveConfig.customServerPersonality && state.customInstructions[guildId]) {
     instructions = state.customInstructions[guildId];
   }
 }

 let infoStr = '';
 if (guildId) {
   const userInfo = {
     username: originalMessage.author.username,
     displayName: originalMessage.author.displayName
   };
   infoStr = `\nYou are currently engaging with users in the ${originalMessage.guild.name} Discord server.\n\n## Current User Information\nUsername: \`${userInfo.username}\`\nDisplay Name: \`${userInfo.displayName}\``;
 }

 const isServerChatHistoryEnabled = guildId ? state.serverSettings[guildId]?.serverChatHistory : false;
 const isChannelChatHistoryEnabled = guildId ? state.channelWideChatHistory[originalMessage.channelId] : false;
 const finalInstructions = instructions + infoStr;
 const historyId = isChannelChatHistoryEnabled ? (isServerChatHistoryEnabled ? guildId : originalMessage.channelId) : userId;

 const tools = [
   { googleSearch: {} },
   { urlContext: {} },
   { codeExecution: {} }
 ];

 const chat = genAI.chats.create({
   model: effectiveConfig.model,
   config: {
     systemInstruction: {
       role: "system",
       parts: [{ text: finalInstructions || defaultPersonality }]
     },
     ...generationConfig,
     safetySettings,
     tools
   },
   history: getHistory(historyId)
 });

 await handleModelResponse(interaction, chat, parts, originalMessage, historyId, overrideMessage);
}

// <==========>


// <=====[Settings Component Builders]=====>

async function showUserSettingsEmbed(interaction) {
 const userId = interaction.user.id;
 const userConfig = state.userSettings[userId] || config.defaultUserSettings;

 const embed = new EmbedBuilder()
   .setColor(userConfig.responseColor || config.hexColour)
   .setTitle('👤 My User Settings')
   .setDescription(`Manage your personal bot preferences here. These settings are global (across DMs and servers), unless overridden by a server administrator.`)
   .addFields(
     { name: 'Model Selector', value: userConfig.model, inline: true },
     { name: 'Continuous Reply', value: userConfig.continuousReply ? 'ON (No Mention)' : 'OFF (Mentions You)', inline: true },
     { name: 'Response Format', value: `${userConfig.responseStyle} (${userConfig.responseColor})`, inline: true },
     { name: 'Action Buttons', value: userConfig.actionButtonsDisplay ? 'VISIBLE' : 'HIDDEN', inline: true },
   )
   .setFooter({ text: 'Model preference will be reset if server override is ON.', iconURL: client.user.displayAvatarURL() })
   .setTimestamp();

 const modelOptions = AVAILABLE_MODELS.map(m =>
   new StringSelectMenuOptionBuilder()
   .setLabel(m.name)
   .setDescription(m.description)
   .setValue(m.id)
   .setDefault(m.id === userConfig.model)
 );

 const modelSelect = new StringSelectMenuBuilder()
   .setCustomId('model-select-user')
   .setPlaceholder('Choose your preferred model...')
   .addOptions(modelOptions);

 const modelRow = new ActionRowBuilder().addComponents(modelSelect);

 const toggleRow = new ActionRowBuilder().addComponents(
   new ButtonBuilder()
   .setCustomId('user-continuous-reply')
   .setLabel(`Continuous Reply: ${userConfig.continuousReply ? 'ON' : 'OFF'}`)
   .setStyle(userConfig.continuousReply ? ButtonStyle.Success : ButtonStyle.Secondary),

   new ButtonBuilder()
   .setCustomId('user-response-style')
   .setLabel(`Format: ${userConfig.responseStyle}`)
   .setStyle(ButtonStyle.Secondary),

   new ButtonBuilder()
   .setCustomId('user-action-buttons')
   .setLabel(`Action Buttons: ${userConfig.actionButtonsDisplay ? 'SHOW' : 'HIDE'}`)
   .setStyle(userConfig.actionButtonsDisplay ? ButtonStyle.Success : ButtonStyle.Secondary),
 );

 const utilityRow = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('clear-user-history').setLabel('Clear History').setEmoji('🧹').setStyle(ButtonStyle.Danger),
   new ButtonBuilder().setCustomId('download-user-history').setLabel('Download History').setEmoji('🗃️').setStyle(ButtonStyle.Secondary),
   new ButtonBuilder().setCustomId('user-custom-personality').setLabel('Set Personality').setEmoji('🙌').setStyle(ButtonStyle.Primary),
   new ButtonBuilder().setCustomId('user-remove-personality').setLabel('Remove Personality').setEmoji('🤖').setStyle(ButtonStyle.Secondary),
 );

 const backRow = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('back-to-main-settings').setLabel('Back to Main').setEmoji('🔙').setStyle(ButtonStyle.Secondary)
 );

 await interaction.update({
   embeds: [embed],
   components: [modelRow, toggleRow, utilityRow, backRow]
 });
}

async function showServerSettingsEmbed(interaction) {
 const serverId = interaction.guild.id;
 const serverConfig = state.serverSettings[serverId] || config.defaultServerSettings;
 const canManageServer = interaction.member.permissions.has(PermissionsBitField.Flags.ManageGuild);

 if (!canManageServer) {
   return interaction.reply({
     content: '❌ You need the **Manage Server** permission to view this panel.',
     flags: MessageFlags.Ephemeral
   });
 }

 const embed = new EmbedBuilder()
   .setColor(serverConfig.responseColor || config.hexColour)
   .setTitle('🏢 Server Settings')
   .setDescription(`Settings applied server-wide. Users with **Manage Server** can configure these.`)
   .addFields(
     { name: 'Model Selector', value: serverConfig.model, inline: true },
     { name: 'Continuous Reply', value: serverConfig.continuousReply ? 'ON' : 'OFF', inline: true },
     { name: 'Response Format', value: `${serverConfig.responseStyle} (${serverConfig.responseColor})`, inline: true },
     { name: 'Action Buttons', value: serverConfig.actionButtonsDisplay ? 'VISIBLE' : 'HIDDEN', inline: true },
     { name: 'Override User Settings', value: serverConfig.overrideUser ? 'ACTIVE ⚠️' : 'INACTIVE', inline: true },
     { name: 'Custom Personality', value: serverConfig.customServerPersonality ? 'ACTIVE' : 'INACTIVE', inline: true },
   )
   .setFooter({ text: 'Only administrators can change these settings.', iconURL: interaction.guild.iconURL() || client.user.displayAvatarURL() })
   .setTimestamp();

 const modelOptions = AVAILABLE_MODELS.map(m =>
   new StringSelectMenuOptionBuilder()
   .setLabel(m.name)
   .setDescription(m.description)
   .setValue(m.id)
   .setDefault(m.id === serverConfig.model)
 );

 const modelSelect = new StringSelectMenuBuilder()
   .setCustomId('model-select-server')
   .setPlaceholder('Choose the server-wide preferred model...')
   .addOptions(modelOptions);

 const modelRow = new ActionRowBuilder().addComponents(modelSelect);

 const toggleRow1 = new ActionRowBuilder().addComponents(
   new ButtonBuilder()
   .setCustomId('server-continuous-reply')
   .setLabel(`Continuous Reply: ${serverConfig.continuousReply ? 'ON' : 'OFF'}`)
   .setStyle(serverConfig.continuousReply ? ButtonStyle.Success : ButtonStyle.Secondary),

   new ButtonBuilder()
   .setCustomId('server-response-style')
   .setLabel(`Format: ${serverConfig.responseStyle}`)
   .setStyle(ButtonStyle.Secondary),

   new ButtonBuilder()
   .setCustomId('server-action-buttons')
   .setLabel(`Action Buttons: ${serverConfig.actionButtonsDisplay ? 'SHOW' : 'HIDE'}`)
   .setStyle(serverConfig.actionButtonsDisplay ? ButtonStyle.Success : ButtonStyle.Secondary),
 );

 const toggleRow2 = new ActionRowBuilder().addComponents(
   new ButtonBuilder()
   .setCustomId('server-override-user')
   .setLabel(`Override User: ${serverConfig.overrideUser ? 'ON' : 'OFF'}`)
   .setEmoji('⚠️')
   .setStyle(serverConfig.overrideUser ? ButtonStyle.Danger : ButtonStyle.Success),

   new ButtonBuilder()
   .setCustomId('server-custom-personality')
   .setLabel(`Custom Personality: ${serverConfig.customServerPersonality ? 'ON' : 'OFF'}`)
   .setStyle(serverConfig.customServerPersonality ? ButtonStyle.Success : ButtonStyle.Secondary),

   new ButtonBuilder()
   .setCustomId('server-remove-personality')
   .setLabel('Remove Personality')
   .setEmoji('🤖')
   .setStyle(ButtonStyle.Secondary),
 );

 const utilityRow = new ActionRowBuilder().addComponents(
   new ButtonBuilder().setCustomId('clear-server-history').setLabel('Clear History').setEmoji('🧹').setStyle(ButtonStyle.Danger),
   new ButtonBuilder().setCustomId('download-server-history').setLabel('Download History').setEmoji('🗃️').setStyle(ButtonStyle.Secondary),
   new ButtonBuilder().setCustomId('back-to-main-settings').setLabel('Back to Main').setEmoji('🔙').setStyle(ButtonStyle.Secondary)
 );


 await interaction.update({
   embeds: [embed],
   components: [modelRow, toggleRow1, toggleRow2, utilityRow]
 });
}

// <==========>


// <=====[Settings Component Handlers]=====>

async function handleModelSelect(interaction) {
 const isServer = interaction.customId.includes('server');
 const newModelId = interaction.values[0];
 const newModelName = AVAILABLE_MODELS.find(m => m.id === newModelId)?.name || newModelId;
 const scopeId = isServer ? interaction.guild.id : interaction.user.id;

 if (isServer) {
   state.serverSettings[scopeId].model = newModelId;
   await showServerSettingsEmbed(interaction);
 } else {
   state.userSettings[scopeId].model = newModelId;
   await showUserSettingsEmbed(interaction);
 }
 await saveStateToFile();
 
 const scope = isServer ? 'Server' : 'User';
 await interaction.followUp({
   content: `✅ ${scope} Model updated to **${newModelName}**!`,
   flags: MessageFlags.Ephemeral
 });
}

async function toggleContinuousReply(interaction) {
 const isServer = interaction.customId.includes('server');
 const scopeId = isServer ? interaction.guild.id : interaction.user.id;
 const configObj = isServer ? state.serverSettings[scopeId] : state.userSettings[scopeId];

 configObj.continuousReply = !configObj.continuousReply;
 await saveStateToFile();

 if (isServer) {
   await showServerSettingsEmbed(interaction);
 } else {
   await showUserSettingsEmbed(interaction);
 }

 const scope = isServer ? 'Server' : 'User';
 await interaction.followUp({
   content: `✅ ${scope} Continuous Reply turned **${configObj.continuousReply ? 'ON' : 'OFF'}**.`,
   flags: MessageFlags.Ephemeral
 });
}

async function handleResponseStyle(interaction) {
 const isServer = interaction.customId.includes('server');
 const scopeId = isServer ? interaction.guild.id : interaction.user.id;
 const configObj = isServer ? state.serverSettings[scopeId] : state.userSettings[scopeId];

 configObj.responseStyle = configObj.responseStyle === 'Embedded' ? 'Normal' : 'Embedded';
 await saveStateToFile();

 const scope = isServer ? 'Server' : 'User';
 const modalId = isServer ? 'server-color-modal' : 'user-color-modal';

 if (configObj.responseStyle === 'Embedded') {
   const colorInput = new TextInputBuilder()
     .setCustomId('hex-color-input')
     .setLabel(`Enter Hex Color Code (e.g., ${config.hexColour})`)
     .setStyle(TextInputStyle.Short)
     .setPlaceholder(configObj.responseColor)
     .setValue(configObj.responseColor)
     .setMinLength(7)
     .setMaxLength(7);

   const modal = new ModalBuilder()
     .setCustomId(modalId)
     .setTitle(`Set ${scope} Embed Color`)
     .addComponents(new ActionRowBuilder().addComponents(colorInput));

   await interaction.showModal(modal);
 } else {
   if (isServer) {
     await showServerSettingsEmbed(interaction);
   } else {
     await showUserSettingsEmbed(interaction);
   }
   await interaction.followUp({
     content: `✅ ${scope} Response Style updated to **Normal** (Text Only).`,
     flags: MessageFlags.Ephemeral
   });
 }
}

async function toggleActionButtons(interaction) {
 const isServer = interaction.customId.includes('server');
 const scopeId = isServer ? interaction.guild.id : interaction.user.id;
 const configObj = isServer ? state.serverSettings[scopeId] : state.userSettings[scopeId];

 configObj.actionButtonsDisplay = !configObj.actionButtonsDisplay;
 await saveStateToFile();

 if (isServer) {
   await showServerSettingsEmbed(interaction);
 } else {
   await showUserSettingsEmbed(interaction);
 }

 const scope = isServer ? 'Server' : 'User';
 await interaction.followUp({
   content: `✅ ${scope} Action Buttons (Stop, Save, Delete) are now **${configObj.actionButtonsDisplay ? 'VISIBLE' : 'HIDDEN'}**.`,
   flags: MessageFlags.Ephemeral
 });
}

async function toggleOverrideUser(interaction) {
 const serverId = interaction.guild.id;
 state.serverSettings[serverId].overrideUser = !state.serverSettings[serverId].overrideUser;
 await saveStateToFile();
 await showServerSettingsEmbed(interaction);

 const newStatus = state.serverSettings[serverId].overrideUser;
 await interaction.followUp({
   content: `✅ Server Override is now **${newStatus ? 'ACTIVE' : 'INACTIVE'}**. When active, server settings override all user preferences.`,
   flags: MessageFlags.Ephemeral
 });
}

// <==========>


// <=====[History & Personality Handlers]=====>

async function clearChatHistory(interaction) {
 try {
   state.chatHistories[interaction.user.id] = {};
   await saveStateToFile();
   const embed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Chat History Cleared')
     .setDescription('Your personal chat history has been cleared!');
   await interaction.reply({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
 } catch (error) {
   console.error(error.message);
 }
}

async function downloadConversation(interaction) {
 try {
   const userId = interaction.user.id;
   const conversationHistory = getHistory(userId);

   if (!conversationHistory || conversationHistory.length === 0) {
     const noHistoryEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('No History Found')
       .setDescription('No personal conversation history found.');
     return interaction.reply({
       embeds: [noHistoryEmbed],
       flags: MessageFlags.Ephemeral
     });
   }

   let conversationText = conversationHistory.map(entry => {
     const role = entry.role === 'user' ? '[User]' : '[Model]';
     const content = entry.parts.map(c => c.text).join('\n');
     return `${role}:\n${content}\n\n`;
   }).join('');

   const tempFileName = path.join(TEMP_DIR, `conversation_${interaction.id}.txt`);
   await fs.writeFile(tempFileName, conversationText, 'utf8');

   const file = new AttachmentBuilder(tempFileName, {
     name: 'conversation_history.txt'
   });

   try {
     await interaction.user.send({
       content: "> `Here's your personal conversation history:`",
       files: [file]
     });

     const dmSentEmbed = new EmbedBuilder()
       .setColor(0x00FF00)
       .setTitle('History Sent')
       .setDescription('Your conversation history has been sent to your DMs.');
     await interaction.reply({
       embeds: [dmSentEmbed],
       flags: MessageFlags.Ephemeral
     });
   } catch (e) {
     await interaction.reply({
       content: `❌ Failed to send DM. Please ensure your DMs are open. Error: \`${e.message}\``,
       files: [file],
       flags: MessageFlags.Ephemeral
     });
   }

   await fs.unlink(tempFileName);
 } catch (error) {
   console.error(`Failed to download conversation: ${error.message}`);
   await interaction.followUp({
     content: `❌ An internal error occurred while downloading history. Error: \`${error.message}\``,
     flags: MessageFlags.Ephemeral
   });
 }
}

async function setCustomPersonality(interaction) {
 const customId = 'user-custom-personality-input';
 const title = 'Enter Custom Personality Instructions';

 const currentInstructions = state.customInstructions[interaction.user.id] || defaultPersonality;

 const input = new TextInputBuilder()
   .setCustomId(customId)
   .setLabel("What should the bot's personality be like?")
   .setStyle(TextInputStyle.Paragraph)
   .setPlaceholder("Enter the custom instructions here...")
   .setValue(currentInstructions)
   .setMinLength(10)
   .setMaxLength(4000);

 const modal = new ModalBuilder()
   .setCustomId('user-personality-modal')
   .setTitle(title)
   .addComponents(new ActionRowBuilder().addComponents(input));

 await interaction.showModal(modal);
}

async function removeCustomPersonality(interaction) {
 try {
   delete state.customInstructions[interaction.user.id];
   await saveStateToFile();
   await showUserSettingsEmbed(interaction);
   const embed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Removed')
     .setDescription('Personal custom personality instructions removed!');

   await interaction.followUp({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
 } catch (error) {
   console.error(error.message);
 }
}

async function clearServerChatHistory(interaction) {
 try {
   const serverId = interaction.guild.id;
   state.chatHistories[serverId] = {};
   await saveStateToFile();
   await showServerSettingsEmbed(interaction);
   const clearedEmbed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Chat History Cleared')
     .setDescription('Server-wide chat history cleared!');
   await interaction.followUp({
     embeds: [clearedEmbed],
     flags: MessageFlags.Ephemeral
   });
 } catch (error) {
   console.error('Failed to clear server-wide chat history:', error.message);
 }
}

async function downloadServerConversation(interaction) {
 try {
   const guildId = interaction.guild.id;
   const conversationHistory = getHistory(guildId);

   if (!conversationHistory || conversationHistory.length === 0) {
     const noHistoryEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('No History Found')
       .setDescription('No server-wide conversation history found.');
     return interaction.reply({
       embeds: [noHistoryEmbed],
       flags: MessageFlags.Ephemeral
     });
   }

   const conversationText = conversationHistory.map(entry => {
     const role = entry.role === 'user' ? '[User]' : '[Model]';
     const content = entry.parts.map(c => c.text).join('\n');
     return `${role}:\n${content}\n\n`;
   }).join('');

   const tempFileName = path.join(TEMP_DIR, `server_conversation_${interaction.id}.txt`);
   await fs.writeFile(tempFileName, conversationText, 'utf8');

   const file = new AttachmentBuilder(tempFileName, {
     name: 'server_conversation_history.txt'
   });

   try {
     await interaction.user.send({
       content: "> `Here's the server-wide conversation history:`",
       files: [file]
     });

     const dmSentEmbed = new EmbedBuilder()
       .setColor(0x00FF00)
       .setTitle('History Sent')
       .setDescription('Server-wide conversation history has been sent to your DMs.');
     await interaction.reply({
       embeds: [dmSentEmbed],
       flags: MessageFlags.Ephemeral
     });
   } catch (e) {
     await interaction.reply({
       content: `❌ Failed to send DM. Please ensure your DMs are open. Error: \`${e.message}\``,
       files: [file],
       flags: MessageFlags.Ephemeral
     });
   }

   await fs.unlink(tempFileName);
 } catch (error) {
   console.error(`Failed to download server conversation: ${error.message}`);
   await interaction.followUp({
     content: `❌ An internal error occurred while downloading server history. Error: \`${error.message}\``,
     flags: MessageFlags.Ephemeral
   });
 }
}

async function serverPersonality(interaction) {
 const customId = 'server-custom-personality-input';
 const title = 'Enter Custom Server Personality Instructions';
 const serverId = interaction.guild.id;

 const currentInstructions = state.customInstructions[serverId] || defaultPersonality;

 const input = new TextInputBuilder()
   .setCustomId(customId)
   .setLabel("What should the bot's server-wide personality be like?")
   .setStyle(TextInputStyle.Paragraph)
   .setPlaceholder("Enter the custom instructions here...")
   .setValue(currentInstructions)
   .setMinLength(10)
   .setMaxLength(4000);

 const modal = new ModalBuilder()
   .setCustomId('server-personality-modal')
   .setTitle(title)
   .addComponents(new ActionRowBuilder().addComponents(input));

 await interaction.showModal(modal);
}

async function removeServerPersonality(interaction) {
 try {
   const serverId = interaction.guild.id;
   delete state.customInstructions[serverId];
   state.serverSettings[serverId].customServerPersonality = false; 
   await saveStateToFile();
   await showServerSettingsEmbed(interaction);
   const embed = new EmbedBuilder()
     .setColor(0x00FF00)
     .setTitle('Removed')
     .setDescription('Server custom personality instructions removed and toggle disabled!');

   await interaction.followUp({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
   });
 } catch (error) {
   console.error(error.message);
 }
}

// <==========>


// <=====[Modal Submit Handlers]=====>

async function handleModalSubmit(interaction) {
 try {
   const userId = interaction.user.id;
   const guildId = interaction.guild?.id;

   if (interaction.customId === 'user-personality-modal') {
     const customInstructionsInput = interaction.fields.getTextInputValue('user-custom-personality-input');
     state.customInstructions[userId] = customInstructionsInput.trim();
     await saveStateToFile();
     const embed = new EmbedBuilder()
       .setColor(0x00FF00)
       .setTitle('Success')
       .setDescription('Personal Custom Personality Instructions Saved!');
     await interaction.reply({
       embeds: [embed],
       flags: MessageFlags.Ephemeral
     });
   } else if (interaction.customId === 'server-personality-modal') {
     const customInstructionsInput = interaction.fields.getTextInputValue('server-custom-personality-input');
     state.customInstructions[guildId] = customInstructionsInput.trim();
     state.serverSettings[guildId].customServerPersonality = true;
     await saveStateToFile();
     const embed = new EmbedBuilder()
       .setColor(0x00FF00)
       .setTitle('Success')
       .setDescription('Server Custom Personality Instructions Saved and toggle enabled!');
     await interaction.reply({
       embeds: [embed],
       flags: MessageFlags.Ephemeral
     });
   } else if (interaction.customId === 'user-color-modal') {
     const hexColorInput = interaction.fields.getTextInputValue('hex-color-input');
     if (/^#([0-9A-F]{3}){1,2}$/i.test(hexColorInput)) {
       state.userSettings[userId].responseColor = hexColorInput.toUpperCase();
       await saveStateToFile();
       await showUserSettingsEmbed(interaction);
       await interaction.followUp({
         content: `✅ User Response Style updated to **Embedded** with color ${hexColorInput.toUpperCase()}.`,
         flags: MessageFlags.Ephemeral
       });
     } else {
       await interaction.reply({
         content: '❌ Invalid Hex Color Code. Please use format `#RRGGBB`.',
         flags: MessageFlags.Ephemeral
       });
     }
   } else if (interaction.customId === 'server-color-modal') {
     const hexColorInput = interaction.fields.getTextInputValue('hex-color-input');
     if (/^#([0-9A-F]{3}){1,2}$/i.test(hexColorInput)) {
       state.serverSettings[guildId].responseColor = hexColorInput.toUpperCase();
       await saveStateToFile();
       await showServerSettingsEmbed(interaction);
       await interaction.followUp({
         content: `✅ Server Response Style updated to **Embedded** with color ${hexColorInput.toUpperCase()}.`,
         flags: MessageFlags.Ephemeral
       });
     } else {
       await interaction.reply({
         content: '❌ Invalid Hex Color Code. Please use format `#RRGGBB`.',
         flags: MessageFlags.Ephemeral
       });
     }
   }
 } catch (error) {
   console.error('Error handling modal submit:', error.message);
 }
}

// <==========>


// <=====[Core Message Processing]=====>

async function handleTextMessage(message) {
 const botId = client.user.id;
 const userId = message.author.id;
 const guildId = message.guild?.id;
 const channelId = message.channel.id;
 let messageContent = message.content.replace(new RegExp(`<@!?${botId}>`), '').trim();

 const { effectiveConfig, overrideMessage } = getEffectiveUserConfig(userId, guildId);

 if (messageContent === '' && !(message.attachments.size > 0 && hasSupportedAttachments(message))) {
   if (activeRequests.has(userId)) {
     activeRequests.delete(userId);
   }
   const embed = new EmbedBuilder()
     .setColor(0x00FFFF)
     .setTitle('Empty Message')
     .setDescription("It looks like you didn't say anything. What would you like to talk about?");
   const botMessage = await message.reply({
     embeds: [embed]
   });
   await addSettingsAndActionButtons(botMessage, effectiveConfig.actionButtonsDisplay, false, botMessage.id);
   return;
 }
 
 message.channel.sendTyping();
 const typingInterval = setInterval(() => {
   message.channel.sendTyping();
 }, 4000);
 setTimeout(() => {
   clearInterval(typingInterval);
 }, 120000);
 
 let botMessage = false;
 let parts;
 try {
   const updateEmbedDescription = (textStatus, mediaStatus, finalized = false) => {
     const textEmoji = textStatus === '✅' ? '✅' : '🔄';
     const mediaEmoji = mediaStatus === '✅' ? '✅' : '🔄';
     return `Let me think...\n\n- ${textEmoji} **Text Attachment Check**\n- ${mediaEmoji} **Media Attachment Check**${finalized ? '\n\n**All checks done. Waiting for the response...**' : ''}`;
   };

   const embed = new EmbedBuilder()
     .setColor(0x00FFFF)
     .setTitle('🧠 Processing Request')
     .setDescription(updateEmbedDescription('🔄', '🔄'));
   
   botMessage = await message.reply({
     embeds: [embed]
   });

   messageContent = await extractFileText(message, messageContent);
   embed.setDescription(updateEmbedDescription('✅', '🔄'));
   await botMessage.edit({
     embeds: [embed]
   });

   parts = await processPromptAndMediaAttachments(messageContent, message);
   embed.setDescription(updateEmbedDescription('✅', '✅', true));
   await botMessage.edit({
     embeds: [embed]
   });

 } catch (error) {
   clearInterval(typingInterval);
   if (activeRequests.has(userId)) activeRequests.delete(userId);
   console.error('Error during message preprocessing:', error);
   const errorEmbed = new EmbedBuilder()
     .setColor(0xFF0000)
     .setTitle('❌ Processing Failed')
     .setDescription(`I failed to process the attachments or text. Error: \`${error.message}\``);
   await botMessage.edit({ embeds: [errorEmbed], components: [] }).catch(e => console.error("Error editing message to show processing error:", e.message));
   return;
 }

 let instructions = effectiveConfig.customPersonality ? state.customInstructions[userId] : defaultPersonality;
 if (guildId) {
   if (state.channelWideChatHistory[channelId]) {
     instructions = state.customInstructions[channelId];
   } else if (effectiveConfig.customServerPersonality && state.customInstructions[guildId]) {
     instructions = state.customInstructions[guildId];
   }
 }

 let infoStr = '';
 if (guildId) {
   const userInfo = {
     username: message.author.username,
     displayName: message.author.displayName
   };
   infoStr = `\nYou are currently engaging with users in the ${message.guild.name} Discord server.\n\n## Current User Information\nUsername: \`${userInfo.username}\`\nDisplay Name: \`${userInfo.displayName}\``;
 }

 const isServerChatHistoryEnabled = guildId ? state.serverSettings[guildId]?.serverChatHistory : false;
 const isChannelChatHistoryEnabled = guildId ? state.channelWideChatHistory[channelId] : false;
 const finalInstructions = instructions + infoStr;
 const historyId = isChannelChatHistoryEnabled ? (isServerChatHistoryEnabled ? guildId : channelId) : userId;

 const tools = [
   { googleSearch: {} },
   { urlContext: {} },
   { codeExecution: {} }
 ];

 const chat = genAI.chats.create({
   model: effectiveConfig.model, 
   config: {
     systemInstruction: {
       role: "system",
       parts: [{ text: finalInstructions || defaultPersonality }]
     },
     ...generationConfig,
     safetySettings,
     tools
   },
   history: getHistory(historyId)
 });

 await handleModelResponse(botMessage, chat, parts, message, typingInterval, historyId, overrideMessage);
}


// **UPDATED:** Includes 'image/gif' support.
function hasSupportedAttachments(message) {
 const supportedFileExtensions = ['.html', '.js', '.css', '.json', '.xml', '.csv', '.py', '.java', '.sql', '.log', '.md', '.txt', '.docx', '.pptx', '.pdf'];

 return message.attachments.some((attachment) => {
   const contentType = (attachment.contentType || "").toLowerCase();
   const fileExtension = path.extname(attachment.name) || '';
   return (
     contentType.startsWith('image/') || // This now includes GIF (image/gif)
     contentType.startsWith('audio/') ||
     contentType.startsWith('video/') ||
     contentType.startsWith('application/pdf') ||
     contentType.startsWith('application/x-pdf') ||
     supportedFileExtensions.includes(fileExtension)
   );
 });
}

async function downloadFile(url, filePath) {
 const writer = createWriteStream(filePath);
 const response = await axios({
   url,
   method: 'GET',
   responseType: 'stream',
 });
 response.data.pipe(writer);
 return new Promise((resolve, reject) => {
   writer.on('finish', resolve);
   writer.on('error', reject);
 });
}

function sanitizeFileName(fileName) {
 return fileName
   .toLowerCase()
   .replace(/[^a-z0-9-]/g, '-')
   .replace(/^-+|-+$/g, '');
}

// **UPDATED:** Includes 'image/gif' in the filtering logic.
async function processPromptAndMediaAttachments(prompt, message) {
 const attachments = JSON.parse(JSON.stringify(Array.from(message.attachments.values())));
 let parts = [{
   text: prompt
 }];

 if (attachments.length > 0) {
   const validAttachments = attachments.filter(attachment => {
     const contentType = (attachment.contentType || "").toLowerCase();
     return contentType.startsWith('image/') || // Includes GIFs
       contentType.startsWith('audio/') ||
       contentType.startsWith('video/') ||
       contentType.startsWith('application/pdf') ||
       contentType.startsWith('application/x-pdf');
   });

   if (validAttachments.length > 0) {
     const attachmentParts = await Promise.all(
       validAttachments.map(async (attachment) => {
         const sanitizedFileName = sanitizeFileName(attachment.name);
         const uniqueTempFilename = `${message.author.id}-${attachment.id}-${sanitizedFileName}`;
         const filePath = path.join(TEMP_DIR, uniqueTempFilename);

         try {
           await retryOperation(() => downloadFile(attachment.url, filePath), 3, 2000);

           const uploadResult = await genAI.files.upload({
             file: filePath,
             config: {
               mimeType: attachment.contentType,
               displayName: sanitizedFileName,
             }
           });

           const name = uploadResult.name;
           if (name === null) {
             throw new Error(`Unable to extract file name from upload result.`);
           }

           // Handle Video/Processing Status 
           if (attachment.contentType.startsWith('video/')) {
             let file = await genAI.files.get({ name: name });
             let attempts = 0;
             const maxAttempts = 15; 
             while (file.state === 'PROCESSING' && attempts < maxAttempts) {
               process.stdout.write(".");
               await delay(10_000); 
               file = await genAI.files.get({ name: name });
               attempts++;
             }
             if (file.state === 'FAILED') {
               throw new Error(`Video processing failed for ${sanitizedFileName} after ${attempts} attempts.`);
             } else if (file.state === 'PROCESSING') {
               throw new Error(`Video processing timed out for ${sanitizedFileName}.`);
             }
           }

           return createPartFromUri(uploadResult.uri, uploadResult.mimeType);
         } catch (error) {
           console.error(`Error processing attachment ${sanitizedFileName}:`, error);
           throw new Error(`Failed to process media attachment '${attachment.name}'. Please try again or with a smaller file.`);
         } finally {
           try {
             await fs.unlink(filePath);
           } catch (unlinkError) {
             if (unlinkError.code !== 'ENOENT') {
               console.error(`Error deleting temporary file ${filePath}:`, unlinkError);
             }
           }
         }
       })
     );
     parts = [...parts, ...attachmentParts.filter(part => part !== null)];
   }
 }
 return parts;
}


async function extractFileText(message, messageContent) {
 if (message.attachments.size > 0) {
   let attachments = Array.from(message.attachments.values());
   for (const attachment of attachments) {
     const fileType = path.extname(attachment.name) || '';
     const fileTypes = ['.html', '.js', '.css', '.json', '.xml', '.csv', '.py', '.java', '.sql', '.log', '.md', '.txt', '.docx', '.pptx'];

     if (fileTypes.includes(fileType)) {
       try {
         let fileContent = await downloadAndReadFile(attachment.url, fileType);
         messageContent += `\n\n[\`${attachment.name}\` File Content]:\n\`\`\`\n${fileContent}\n\`\`\``;
       } catch (error) {
         console.error(`Error reading file ${attachment.name}: ${error.message}`);
         throw new Error(`Failed to extract text from file '${attachment.name}'. It might be corrupted or unsupported.`);
       }
     }
   }
 }
 return messageContent;
}

async function downloadAndReadFile(url, fileType) {
 switch (fileType) {
   case '.pptx':
   case '.docx':
     const extractor = getTextExtractor();
     return (await extractor.extractText({
       input: url,
       type: 'url'
     }));
   default:
     const response = await fetch(url);
     if (!response.ok) throw new Error(`Failed to download ${response.statusText}`);
     return await response.text();
 }
}

// <==========>


// <=====[Model Response Handling]=====>

async function handleModelResponse(botMessageOrInteraction, chat, parts, originalMessage, historyId, overrideMessage) {
 const isInteraction = botMessageOrInteraction.isChatInputCommand && botMessageOrInteraction.isChatInputCommand();
 const userId = originalMessage.author.id;
 const guildId = originalMessage.guild?.id;
 const {
   responseStyle,
   responseColor,
   actionButtonsDisplay
 } = getEffectiveUserConfig(userId, guildId);

 // Set limits: 3900 for embeds (4096 max) and 1900 for content (2000 max)
 const maxCharacterLimit = responseStyle === 'Embedded' ? 3900 : 1900;
 let attempts = 3;

 let updateTimeout;
 let tempResponse = '';
 let groundingMetadata = null;
 let urlContextMetadata = null;

 const stopGeneratingButton = new ActionRowBuilder()
   .addComponents(
     new ButtonBuilder()
     .setCustomId('stopGenerating')
     .setLabel('Stop Generating')
     .setStyle(ButtonStyle.Danger)
   );

 let botMessage;
 if (isInteraction) {
   botMessage = await botMessageOrInteraction.editReply({
     content: 'Thinking...',
     embeds: [],
     components: actionButtonsDisplay ? [stopGeneratingButton] : []
   });
 } else {
   botMessage = botMessageOrInteraction;
   try {
     await botMessage.edit({
       content: 'Thinking...',
       embeds: [],
       components: actionButtonsDisplay ? [stopGeneratingButton] : []
     });
   } catch (error) {}
 }
 
 activeRequests.set(userId, { botMessageId: botMessage.id, stopGeneration: false });
 const requestInfo = activeRequests.get(userId);

 clearInterval(originalMessage.channel.typing);
 setTimeout(() => clearInterval(originalMessage.channel.typing), 120000);


 const updateMessage = () => {
   if (requestInfo.stopGeneration) {
     return;
   }
   if (tempResponse.trim() === "") {
     botMessage.edit({
       content: '...'
     });
   } else if (responseStyle === 'Embedded') {
     updateEmbed(botMessage, tempResponse, originalMessage, responseColor, groundingMetadata, urlContextMetadata, overrideMessage);
   } else {
     let finalContent = tempResponse;
     if (overrideMessage) {
       finalContent = `${overrideMessage}\n\n${finalContent}`;
     }
     botMessage.edit({
       content: finalContent,
       embeds: []
     });
   }
   clearTimeout(updateTimeout);
   updateTimeout = null;
 };

 while (attempts > 0 && !requestInfo.stopGeneration) {
   try {
     let finalResponse = '';
     let isLargeResponse = false;
     const newHistory = [];
     newHistory.push({
       role: 'user',
       content: parts
     });
     async function getResponse(parts) {
       let newResponse = '';
       const messageResult = await chat.sendMessageStream({
         message: parts
       });
       for await (const chunk of messageResult) {
         if (requestInfo.stopGeneration) break;

         const chunkText = (chunk.text || (chunk.codeExecutionResult?.output ? `\n\`\`\`py\n${chunk.codeExecutionResult.output}\n\`\`\`\n` : "") || (chunk.executableCode ? `\n\`\`\`\n${chunk.executableCode}\n\`\`\`\n` : ""));
         if (chunkText && chunkText !== '') {
           finalResponse += chunkText;
           tempResponse += chunkText;
           newResponse += chunkText;
         }

         if (chunk.candidates && chunk.candidates[0]?.groundingMetadata) {
           groundingMetadata = chunk.candidates[0].groundingMetadata;
         }

         if (chunk.candidates && chunk.candidates[0]?.url_context_metadata) {
           urlContextMetadata = chunk.candidates[0].url_context_metadata;
         }

         if (finalResponse.length > maxCharacterLimit) {
           if (!isLargeResponse) {
             isLargeResponse = true;
             const embed = new EmbedBuilder()
               .setColor(0xFFFF00)
               .setTitle('Response Overflow')
               .setDescription('The response got too large. It will be sent as a separate text file once completed.');

             botMessage.edit({
               embeds: [embed],
               components: []
             });
           }
         } else if (!updateTimeout) {
           updateTimeout = setTimeout(updateMessage, 500);
         }
       }
       newHistory.push({
         role: 'assistant',
         content: [{
           text: newResponse
         }]
       });
     }
     await getResponse(parts);

     // Final update
     if (isLargeResponse) {
       // **CRITICAL CHANGE:** Send as file if too long
       await sendAsTextFile(finalResponse, originalMessage, botMessage.id);
       // Then delete the original 'Response Overflow' message
       await botMessage.delete().catch(e => console.error("Could not delete overflow message:", e.message)); 
     } else if (responseStyle === 'Embedded') {
       updateEmbed(botMessage, finalResponse, originalMessage, responseColor, groundingMetadata, urlContextMetadata, overrideMessage);
     } else {
       let finalContent = finalResponse;
       if (overrideMessage) {
         finalContent = `${overrideMessage}\n\n${finalContent}`;
       }
       await botMessage.edit({
         content: finalContent,
         embeds: []
       });
     }

     // Finalize buttons
     if (!isLargeResponse) {
       await addSettingsAndActionButtons(botMessage, actionButtonsDisplay, isLargeResponse, botMessage.id);
     }

     await chatHistoryLock.runExclusive(async () => {
       updateChatHistory(historyId, newHistory, botMessage.id);
       await saveStateToFile();
     });
     break;
   } catch (error) {
     console.error('Generation Attempt Failed: ', util.inspect(error, { depth: 5 }));
     attempts--;

     if (requestInfo.stopGeneration) {
       break;
     }
     
     if (attempts === 0) {
       const errorEmbed = new EmbedBuilder()
         .setColor(0xFF0000)
         .setTitle('❌ Generation Failure')
         .setDescription(`All Generation Attempts Failed :(\n\`\`\`${error.message}\`\`\``);

       const errorMsg = await originalMessage.channel.send({
         content: `<@${originalMessage.author.id}>`,
         embeds: [errorEmbed]
       });
       await addSettingsAndActionButtons(errorMsg, actionButtonsDisplay, false, errorMsg.id);
       
       // Delete the original bot message if it's the temporary one
       await botMessage.delete().catch(e => console.error("Could not delete failed message:", e.message));
       
       break;
     } else if (SEND_RETRY_ERRORS_TO_DISCORD) {
       const errorMsg = await originalMessage.channel.send({
         content: `<@${originalMessage.author.id}>`,
         embeds: [new EmbedBuilder()
           .setColor(0xFFFF00)
           .setTitle('Retry in Progress')
           .setDescription(`Generation Attempt(s) Failed, Retrying..`)
         ]
       });
       setTimeout(() => errorMsg.delete().catch(console.error), 5000);
       await delay(500);
     }
   }
 }
 if (activeRequests.has(userId)) {
   activeRequests.delete(userId);
 }
}

function updateEmbed(botMessage, finalResponse, message, embedColor, groundingMetadata = null, urlContextMetadata = null, overrideMessage = '') {
 try {
   const isGuild = message.guild !== null;

   let description = finalResponse;
   if (overrideMessage) {
     description = `${overrideMessage}\n\n${description}`;
   }

   const embed = new EmbedBuilder()
     .setColor(embedColor)
     .setDescription(description)
     .setAuthor({
       name: `To ${message.author.displayName}`,
       iconURL: message.author.displayAvatarURL()
     })
     .setTimestamp();

   if (groundingMetadata) {
     addGroundingMetadataToEmbed(embed, groundingMetadata);
   }
   if (urlContextMetadata) {
     addUrlContextMetadataToEmbed(embed, urlContextMetadata);
   }

   if (isGuild) {
     embed.setFooter({
       text: message.guild.name,
       iconURL: message.guild.iconURL() || 'https://ai.google.dev/static/site-assets/images/share.png'
     });
   }

   botMessage.edit({
     content: ' ',
     embeds: [embed]
   });
 } catch (error) {
   console.error("An error occurred while updating the embed:", error.message);
 }
}

async function addSettingsAndActionButtons(botMessage, displayActionButtons, isLargeResponse, msgId, generationFailed = false) {
 try {
   const finalComponents = [];
   let actionRow = new ActionRowBuilder();

   if (!generationFailed) {
     const settingsButton = new ButtonBuilder()
       .setCustomId('settings')
       .setEmoji('⚙️')
       .setLabel('Settings')
       .setStyle(ButtonStyle.Secondary);
     actionRow.addComponents(settingsButton);
   }
   
   if (displayActionButtons && !generationFailed) {
     if (!isLargeResponse) {
       const downloadButton = new ButtonBuilder()
         .setCustomId('download-message')
         .setLabel('Save')
         .setEmoji('⬇️')
         .setStyle(ButtonStyle.Secondary);
       actionRow.addComponents(downloadButton);
     }
     
     const deleteButton = new ButtonBuilder()
       .setCustomId(`delete_message-${msgId}`)
       .setLabel('Delete')
       .setEmoji('🗑️')
       .setStyle(ButtonStyle.Secondary);
     actionRow.addComponents(deleteButton);
   }

   if (actionRow.components.length > 0) {
     finalComponents.push(actionRow);
   }

   // Disable any lingering 'Stop Generating' buttons
   const existingComponents = botMessage.components || [];
   const updatedComponents = existingComponents.map(row => {
       const newRow = ActionRowBuilder.from(row);
       newRow.components.forEach(c => {
           if (c.customId === 'stopGenerating') {
               c.setDisabled(true).setLabel('Complete');
               c.setStyle(ButtonStyle.Success);
           }
       });
       return newRow;
   });

   finalComponents.unshift(...updatedComponents.filter(row => row.components.some(c => c.customId === 'stopGenerating')));
   
   if (finalComponents.length > 0) {
     await botMessage.edit({ components: finalComponents });
   } else {
     await botMessage.edit({ components: [] });
   }

 } catch (error) {
   console.error('Error adding final action buttons:', error.message);
 }
}


function addGroundingMetadataToEmbed(embed, groundingMetadata) {
 if (groundingMetadata.webSearchQueries && groundingMetadata.webSearchQueries.length > 0) {
   embed.addFields({
     name: '🔍 Search Queries',
     value: groundingMetadata.webSearchQueries.map(query => `• ${query}`).join('\n'),
     inline: false
   });
 }

 if (groundingMetadata.groundingAttributions && groundingMetadata.groundingAttributions.length > 0) {
   const chunks = groundingMetadata.groundingAttributions
     .slice(0, 5) 
     .map((attribution, index) => {
       if (attribution.web) {
         return `• [${attribution.web.title || 'Source'}](${attribution.web.uri})`;
       }
       return `• Source ${index + 1}`;
     })
     .join('\n');
   
   embed.addFields({
     name: '📚 Sources',
     value: chunks,
     inline: false
   });
 }
}

function addUrlContextMetadataToEmbed(embed, urlContextMetadata) {
 if (urlContextMetadata.url_metadata && urlContextMetadata.url_metadata.length > 0) {
   const urlList = urlContextMetadata.url_metadata
     .map(urlData => {
       const emoji = urlData.url_retrieval_status === 'URL_RETRIEVAL_STATUS_SUCCESS' ? '✔️' : '❌';
       return `${emoji} ${urlData.retrieved_url}`;
     })
     .join('\n');
   
   embed.addFields({
     name: '🔗 URL Context',
     value: urlList,
     inline: false
   });
 }
}

// **CRITICAL CHANGE:** Separated function for sending long responses as file
async function sendAsTextFile(text, message, orgId) {
 try {
   const filename = `response-${Date.now()}.txt`;
   const tempFilePath = path.join(TEMP_DIR, filename);
   await fs.writeFile(tempFilePath, text);

   const botMessage = await message.channel.send({
     content: `<@${message.author.id}>, The full response was too long and is provided here as a text file:`,
     files: [tempFilePath]
   });
   
   const shouldDisplayActionButtons = getEffectiveUserConfig(message.author.id, message.guild?.id).actionButtonsDisplay;
   // Add buttons to the *new* message
   await addSettingsAndActionButtons(botMessage, shouldDisplayActionButtons, true, orgId);

   await fs.unlink(tempFilePath);
 } catch (error) {
   console.error('An error occurred in sendAsTextFile:', error);
 }
}

async function downloadMessage(interaction) {
 try {
   const message = interaction.message;
   let textContent = message.content;
   
   // Check if the content is in the embed description
   if (!textContent && message.embeds.length > 0 && message.embeds[0].description) {
     textContent = message.embeds[0].description;
   }
   
   // Check if the content is in a quoted reply (if the original message was deleted)
   if (!textContent && message.reference) {
       const referencedMessage = await message.channel.messages.fetch(message.reference.messageId).catch(() => null);
       if (referencedMessage) {
           textContent = referencedMessage.content;
       }
   }

   if (!textContent) {
     const emptyEmbed = new EmbedBuilder()
       .setColor(0xFF0000)
       .setTitle('Empty Message')
       .setDescription('The message content is empty or could not be retrieved.');
     await interaction.reply({
       embeds: [emptyEmbed],
       flags: MessageFlags.Ephemeral
     });
     return;
   }

   const filePath = path.join(TEMP_DIR, `message_content_${interaction.id}.txt`);
   await fs.writeFile(filePath, textContent, 'utf8');

   const attachment = new AttachmentBuilder(filePath, {
     name: 'message_content.txt'
   });

   const initialEmbed = new EmbedBuilder()
     .setColor(0xFFFFFF)
     .setTitle('Message Content Downloaded')
     .setDescription(`Here is the content of the message.`);

   let response;
   try {
       response = await interaction.user.send({
           embeds: [initialEmbed],
           files: [attachment]
       });
       const dmSentEmbed = new EmbedBuilder()
           .setColor(0x00FF00)
           .setTitle('Content Sent')
           .setDescription('The message content has been sent to your DMs.');
       await interaction.reply({
           embeds: [dmSentEmbed],
           flags: MessageFlags.Ephemeral
       });
   } catch (error) {
       console.error(`Failed to send DM: ${error}`);
       const failDMEmbed = new EmbedBuilder()
           .setColor(0xFF0000)
           .setTitle('Delivery Failed')
           .setDescription('Failed to send the content to your DMs. Sending here instead.');
       
       response = await interaction.reply({
           embeds: [failDMEmbed],
           files: [attachment],
           flags: MessageFlags.Ephemeral,
           fetchReply: true
       });
   }

   await fs.unlink(filePath);

   const msgUrl = await uploadText(textContent);
   
   // Edit the message with the URL
   if (msgUrl !== '\nURL Error :(') {
     const updatedEmbed = EmbedBuilder.from(response.embeds[0])
       .setDescription(`Here is the content of the message. The content has also been uploaded for easy sharing: ${msgUrl}`);

     if (response.channel.type === ChannelType.DM) {
       await response.edit({
         embeds: [updatedEmbed]
       });
     } else {
       await interaction.editReply({
         embeds: [updatedEmbed]
       });
     }
   }

 } catch (error) {
   console.error('Failed to process download: ', error);
   await interaction.followUp({
     content: `❌ An unexpected error occurred during download: \`${error.message}\``,
     flags: MessageFlags.Ephemeral
   });
 }
}

const uploadText = async (text) => {
 const siteUrl = 'https://bin.mudfish.net';
 try {
   const response = await axios.post(`${siteUrl}/api/text`, {
     text: text,
     ttl: 10080
   }, {
     timeout: 3000
   });

   const key = response.data.tid;
   return `\nURL: ${siteUrl}/t/${key}`;
 } catch (error) {
   console.error(error.message);
   return '\nURL Error :(';
 }
};

async function handleDeleteMessageInteraction(interaction, msgId) {
 const userId = interaction.user.id;
 const channel = interaction.channel;
 const originalBotMessage = channel ? (await channel.messages.fetch(msgId).catch(() => false)) : false;

 const { isServerChatHistoryEnabled, historyId } = (interaction.guild ? {
   isServerChatHistoryEnabled: state.serverSettings[interaction.guild.id]?.serverChatHistory,
   historyId: state.serverSettings[interaction.guild.id]?.serverChatHistory ? interaction.guild.id : userId
 } : { isServerChatHistoryEnabled: false, historyId: userId });


 // 1. Check if the message ID exists in the history (for either user or server)
 if (state.chatHistories[historyId] && state.chatHistories[historyId][msgId]) {
     delete state.chatHistories[historyId][msgId];
     await saveStateToFile();
     await deleteMsg();
     return;
 } 
 
 // 2. Fallback check: check if user is the author of the *original request*
 try {
     if (originalBotMessage && originalBotMessage.reference) {
         const replyingToMsg = await originalBotMessage.channel.messages.fetch(originalBotMessage.reference.messageId);
         if (userId === replyingToMsg.author.id || interaction.user.id === originalBotMessage.author.id) {
             await deleteMsg();
             return;
         }
     }
 } catch (error) {}

 // 3. Deny access if no condition met
 const embed = new EmbedBuilder()
     .setColor(0xFF0000)
     .setTitle('Not For You')
     .setDescription('This button is only for the person who initiated the request or the bot response.');
 return interaction.reply({
     embeds: [embed],
     flags: MessageFlags.Ephemeral
 });


 async function deleteMsg() {
   await interaction.message.delete()
     .catch(e => console.error('Error deleting interaction message: ', e));

   if (channel && originalBotMessage) {
     originalBotMessage.delete().catch(() => {});
   }
 }
}

client.login(token);